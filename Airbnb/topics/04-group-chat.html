<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Airbnb Group Chat Messaging System - System Design</title>
<style>
  :root {
    --primary: #FF5A5F;
    --primary-dark: #E04850;
    --secondary: #00A699;
    --accent: #FC642D;
    --purple: #7B2FF7;
    --blue: #428BF9;
    --dark: #ffffff;
    --darker: #f1f5f9;
    --card-bg: #ffffff;
    --card-border: #e2e8f0;
    --text: #1e293b;
    --text-muted: #4b5563;
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--dark);
    color: var(--text);
    line-height: 1.7;
    scroll-behavior: smooth;
  }

  /* ===== HERO ===== */
  .hero {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #6B73FF 100%);
    padding: 60px 40px 50px;
    text-align: center;
    border-bottom: 3px solid var(--primary);
    position: relative;
    overflow: hidden;
  }
  .hero::before {
    content: '';
    position: absolute;
    top: -50%; left: -50%;
    width: 200%; height: 200%;
    background: radial-gradient(circle at 30% 50%, rgba(255,90,95,0.15) 0%, transparent 50%),
                radial-gradient(circle at 70% 50%, rgba(0,166,153,0.15) 0%, transparent 50%);
    animation: pulse 8s ease-in-out infinite;
  }
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  .hero h1 {
    font-size: 2.6em;
    background: linear-gradient(135deg, #ffffff, #e0e7ff, #ffffff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    position: relative;
    margin-bottom: 10px;
  }
  .hero .subtitle {
    font-size: 1.15em;
    color: rgba(255,255,255,0.9);
    position: relative;
    margin-bottom: 8px;
  }
  .hero .topic-badges {
    position: relative;
    margin-top: 15px;
  }
  .hero .back-link {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin-top: 18px;
    color: #ffffff;
    text-decoration: none;
    font-size: 0.95em;
    font-weight: 600;
    position: relative;
    border: 1px solid rgba(255,255,255,0.4);
    background: rgba(255,255,255,0.15);
    padding: 10px 24px;
    border-radius: 10px;
    transition: all 0.3s;
  }
  .hero .back-link:hover {
    background: rgba(255,255,255,0.25);
    border-color: #ffffff;
    transform: translateX(-3px);
  }
  .hero .stats-row {
    position: relative;
    display: flex;
    justify-content: center;
    gap: 40px;
    margin-top: 25px;
    flex-wrap: wrap;
  }
  .hero .stat-item { text-align: center; }
  .hero .stat-value {
    font-size: 1.8em;
    font-weight: 800;
    color: var(--primary);
  }
  .hero .stat-label {
    font-size: 0.78em;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1.5px;
  }

  /* ===== BADGES ===== */
  .badge {
    display: inline-block;
    padding: 4px 14px;
    border-radius: 20px;
    font-size: 0.78em;
    font-weight: 600;
    margin: 3px 2px;
    white-space: nowrap;
  }
  .badge-red { background: rgba(255,255,255,0.15); color: #ffffff; border: 1px solid rgba(255,255,255,0.3); }
  .badge-green { background: rgba(0,166,153,0.2); color: #ffffff; border: 1px solid var(--secondary); }
  .badge-blue { background: rgba(255,255,255,0.15); color: #ffffff; border: 1px solid rgba(255,255,255,0.3); }
  .badge-purple { background: rgba(255,255,255,0.15); color: #ffffff; border: 1px solid rgba(255,255,255,0.3); }
  .badge-orange { background: rgba(255,255,255,0.15); color: #ffffff; border: 1px solid rgba(255,255,255,0.3); }
  .badge-medium-hard { background: rgba(123,47,247,0.15); color: var(--purple); border: 1px solid var(--purple); }

  /* ===== TABLE OF CONTENTS NAV ===== */
  .toc {
    background: #f8fafc;
    padding: 20px 40px;
    border-bottom: 1px solid var(--card-border);
    position: sticky;
    top: 0;
    z-index: 100;
    backdrop-filter: blur(10px);
  }
  .toc h2 {
    color: var(--secondary);
    margin-bottom: 10px;
    font-size: 0.85em;
    text-transform: uppercase;
    letter-spacing: 2px;
  }
  .toc-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }
  .toc a {
    color: var(--text-muted);
    text-decoration: none;
    padding: 6px 16px;
    border-radius: 8px;
    font-size: 0.82em;
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    background: var(--card-bg);
    transition: all 0.3s;
    white-space: nowrap;
  }
  .toc a:hover {
    color: var(--primary);
    border-color: var(--primary);
    background: rgba(255,90,95,0.1);
  }

  /* ===== CONTAINER ===== */
  .container { max-width: 1200px; margin: 0 auto; padding: 30px 40px; }
  section { margin-bottom: 55px; }
  section > h2,
  section > details > summary > h2 {
    font-size: 1.7em;
    margin-bottom: 25px;
    padding-bottom: 12px;
    border-bottom: 2px solid #e5e7eb;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  /* ===== COLLAPSIBLE SECTIONS ===== */
  section > details > summary {
    cursor: pointer;
    list-style: none;
    position: relative;
    padding-left: 30px;
  }
  section > details > summary::-webkit-details-marker { display: none; }
  section > details > summary::marker { display: none; content: ''; }
  section > details > summary::before {
    content: 'â–¸';
    position: absolute;
    left: 0;
    top: 10px;
    font-size: 1.3em;
    color: var(--primary);
    transition: transform 0.25s ease;
    font-weight: bold;
  }
  section > details[open] > summary::before { transform: rotate(90deg); }
  section > details > summary > h2 { margin-bottom: 0; flex: 1; }
  .section-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 42px; height: 42px;
    border-radius: 10px;
    font-size: 1.2em;
    flex-shrink: 0;
  }
  h3 {
    font-size: 1.25em;
    color: var(--blue);
    margin: 25px 0 14px;
  }
  h4 {
    font-size: 1.05em;
    color: #ffffff;
    margin: 18px 0 10px;
  }
  p { margin-bottom: 12px; }
  ul, ol { margin: 10px 0 16px 24px; }
  li { margin-bottom: 6px; }

  /* ===== CARDS ===== */
  .card {
    background: var(--card-bg);
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 12px;
    padding: 25px;
    margin-bottom: 20px;
    transition: border-color 0.3s;
  }
  .card:hover { border-color: rgba(255,90,95,0.3); }
  .card h4 {
    font-size: 1.1em;
    margin-bottom: 12px;
    margin-top: 0;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
  }

  /* ===== TABLES ===== */
  .table-wrap {
    overflow-x: auto;
    border-radius: 12px;
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    margin-bottom: 20px;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.88em;
  }
  th {
    background: #f8fafc;
    padding: 13px 16px;
    text-align: left;
    font-weight: 600;
    color: #1e293b;
    border-bottom: 2px solid #e5e7eb;
    white-space: nowrap;
  }
  td {
    padding: 11px 16px;
    border-bottom: 1px solid var(--card-border);
    vertical-align: top;
  }
  tr:hover td { background: rgba(66,139,249,0.04); }
  tr:last-child td { border-bottom: none; }

  /* ===== CODE BLOCKS ===== */
  pre {
    background: #f6f8fa;
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 10px;
    padding: 20px;
    overflow-x: auto;
    margin: 14px 0 20px;
    font-size: 0.85em;
    line-height: 1.6;
  }
  code {
    font-family: 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
    color: #24292f;
  }
  :not(pre) > code {
    background: rgba(66,139,249,0.1);
    padding: 2px 7px;
    border-radius: 5px;
    font-size: 0.88em;
    color: var(--blue);
  }
  .keyword { color: #cf222e; }
  .string { color: #0a3069; }
  .comment { color: #6e7781; font-style: italic; }
  .type { color: #8250df; }
  .number { color: #0550ae; }
  .func { color: #953800; }

  /* ===== TIP / WARNING / INFO BOXES ===== */
  .tip-box {
    border-radius: 10px;
    padding: 18px 22px;
    margin: 16px 0 20px;
    font-size: 0.92em;
    border-left: 4px solid;
  }
  .tip-box.tip {
    background: rgba(255,255,255,0.15);
    border-color: #ffffff;
    color: var(--text);
  }
  .tip-box.warning {
    background: rgba(245,158,11,0.06);
    border-color: var(--warning);
    color: var(--text);
  }
  .tip-box.danger {
    background: rgba(239,68,68,0.06);
    border-color: var(--danger);
    color: var(--text);
  }
  .tip-box.info {
    background: rgba(66,139,249,0.08);
    border-color: var(--blue);
    color: var(--text);
  }
  .tip-box.purple {
    background: rgba(123,47,247,0.08);
    border-color: var(--purple);
    color: var(--text);
  }
  .tip-box strong {
    display: block;
    margin-bottom: 6px;
  }

  /* ===== DIAGRAM / FLOW ===== */
  .diagram {
    background: #f6f8fa;
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 12px;
    padding: 25px;
    margin: 16px 0 20px;
    font-family: 'Cascadia Code', 'Fira Code', monospace;
    font-size: 0.82em;
    line-height: 1.5;
    overflow-x: auto;
    white-space: pre;
    color: var(--text-muted);
  }
  .diagram-box {
    background: rgba(0,0,0,0.05);
    border-radius: 12px;
    padding: 20px;
    overflow-x: auto;
    margin: 20px 0;
  }

  /* ===== COMPARISON GRID ===== */
  .compare-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 16px 0 20px;
  }
  .compare-card {
    background: var(--card-bg);
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 12px;
    padding: 22px;
  }
  .compare-card.pull { border-top: 3px solid var(--blue); }
  .compare-card.push { border-top: 3px solid var(--secondary); }
  .compare-card h4 { margin-top: 0; }

  /* ===== ER DIAGRAM STYLE ===== */
  .er-table {
    background: var(--card-bg);
    border: 2px solid var(--card-border);
    border-radius: 10px;
    overflow: hidden;
    margin: 12px 0;
    min-width: 260px;
  }
  .er-table .er-header {
    background: #f8fafc;
    padding: 10px 16px;
    font-weight: 700;
    font-size: 0.95em;
    border-bottom: 2px solid #e5e7eb;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .er-table .er-row {
    padding: 6px 16px;
    font-size: 0.85em;
    border-bottom: 1px solid rgba(51,65,85,0.5);
    display: flex;
    justify-content: space-between;
    gap: 12px;
  }
  .er-table .er-row:last-child { border-bottom: none; }
  .er-col { color: var(--text); }
  .er-type { color: var(--text-muted); font-family: monospace; font-size: 0.92em; }
  .er-pk { color: var(--warning); font-weight: 600; }
  .er-fk { color: var(--purple); }
  .er-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
    margin: 20px 0;
  }

  /* ===== LIFECYCLE FLOW ===== */
  .flow-steps {
    display: flex;
    flex-wrap: wrap;
    gap: 0;
    margin: 20px 0;
    align-items: center;
  }
  .flow-step {
    background: var(--card-bg);
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 10px;
    padding: 14px 20px;
    text-align: center;
    font-size: 0.88em;
    font-weight: 600;
    min-width: 130px;
  }
  .flow-step .step-label {
    font-size: 0.72em;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1px;
    display: block;
    margin-bottom: 4px;
    font-weight: 400;
  }
  .flow-arrow {
    color: var(--primary);
    font-size: 1.4em;
    padding: 0 8px;
    flex-shrink: 0;
  }

  /* ===== CALIBRATION METER ===== */
  .calibration {
    margin: 20px 0;
  }
  .calibration-row {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 14px;
  }
  .calibration-label {
    min-width: 130px;
    font-weight: 700;
    font-size: 0.9em;
    text-align: right;
  }
  .calibration-bar {
    flex: 1;
    height: 32px;
    background: rgba(255,255,255,0.05);
    border-radius: 8px;
    overflow: hidden;
    position: relative;
  }
  .calibration-fill {
    height: 100%;
    border-radius: 8px;
    display: flex;
    align-items: center;
    padding-left: 14px;
    font-size: 0.78em;
    font-weight: 600;
    color: #fff;
    transition: width 0.5s ease;
  }
  .cal-baseline { background: linear-gradient(90deg, #64748b, #94a3b8); width: 35%; }
  .cal-good { background: linear-gradient(90deg, var(--blue), #60a5fa); width: 55%; }
  .cal-yes { background: linear-gradient(90deg, var(--secondary), #34d399); width: 78%; }
  .cal-strong { background: linear-gradient(90deg, var(--success), #6ee7b7); width: 95%; }

  /* ===== FOOTER ===== */
  .footer {
    text-align: center;
    padding: 40px 30px;
    color: var(--text-muted);
    font-size: 0.85em;
    border-top: 1px solid #e5e7eb;
  }
  .footer a {
    color: #ffffff;
    text-decoration: none;
  }
  .footer a:hover { color: var(--primary); }

  /* ===== RESPONSIVE ===== */
  @media (max-width: 768px) {
    .hero { padding: 40px 20px 35px; }
    .hero h1 { font-size: 1.7em; }
    .toc { padding: 14px 20px; }
    .container { padding: 20px 16px; }
    .card-grid { grid-template-columns: 1fr; }
    .compare-grid { grid-template-columns: 1fr; }
    .er-grid { grid-template-columns: 1fr; }
    section > h2 { font-size: 1.3em; }
    .hero .stats-row { gap: 20px; }
    .flow-steps { flex-direction: column; }
    .flow-arrow { transform: rotate(90deg); }
    .calibration-row { flex-direction: column; gap: 6px; }
    .calibration-label { text-align: left; min-width: unset; }
    table { font-size: 0.82em; display: block; overflow-x: auto; -webkit-overflow-scrolling: touch; }
    .diagram-box { overflow-x: auto; -webkit-overflow-scrolling: touch; }
    .diagram-box svg { min-width: 600px; }
  }
  @media (max-width: 480px) {
    .hero h1 { font-size: 1.4em; }
    pre { font-size: 0.75em; padding: 14px; }
  }
  @media (max-width: 360px) {
    .hero h1 { font-size: 1.15em; }
    .hero .stat-value { font-size: 1em; }
    .container { padding: 10px 8px; }
  }
  /* === DIAGRAM ZOOM CONTROLS === */
  .diagram-box { position: relative; }
  .diagram-zoom-controls {
    position: absolute; top: 12px; right: 12px; z-index: 10;
    display: flex; gap: 4px; opacity: 0.5; transition: opacity 0.3s;
  }
  .diagram-box:hover .diagram-zoom-controls { opacity: 1; }
  .diagram-zoom-controls button {
    width: 32px; height: 32px; border-radius: 8px; border: 1px solid #e5e7eb;
    background: #ffffff; color: #1e293b; cursor: pointer; font-size: 16px;
    display: flex; align-items: center; justify-content: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: all 0.2s;
    font-family: system-ui; line-height: 1; padding: 0;
  }
  .diagram-zoom-controls button:hover { background: #f1f5f9; border-color: var(--blue); color: var(--blue); }
  .diagram-zoom-controls button:active { transform: scale(0.95); }
  .diagram-zoom-controls .zoom-level {
    font-size: 11px; color: #64748b; display: flex; align-items: center;
    padding: 0 6px; font-weight: 600; min-width: 40px; justify-content: center;
  }
  .diagram-box svg { transition: transform 0.3s ease; transform-origin: center center; }
  .diagram-box.fullscreen {
    position: fixed !important; top: 0; left: 0; width: 100vw; height: 100vh;
    z-index: 9999; background: #ffffff; border-radius: 0; padding: 20px;
    display: flex; align-items: center; justify-content: center;
    overflow: auto;
  }
  .diagram-box.fullscreen .diagram-zoom-controls { opacity: 1; top: 20px; right: 20px; }

  /* ===== COLLAPSIBLE SECTIONS ===== */
  details { margin-bottom: 0; }
  details summary { cursor: pointer; list-style: none; user-select: none; padding: 0; }
  details summary::-webkit-details-marker { display: none; }
  details summary::marker { display: none; content: ''; }
  details summary h2 { display: inline-flex; }
  details summary h2::before {
    content: '\25B6'; display: inline-flex; align-items: center;
    margin-right: 8px; transition: transform 0.2s; font-size: 0.5em; color: var(--text-muted);
  }
  details[open] summary h2::before { transform: rotate(90deg); }
  .toggle-controls { display: flex; gap: 8px; margin-top: 10px; }
  .toggle-controls button {
    padding: 5px 14px; border-radius: 8px; border: 1px solid #e5e7eb;
    background: var(--card-bg); color: var(--text-muted); font-size: 0.78em;
    cursor: pointer; transition: all 0.3s; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
  }
  .toggle-controls button:hover { color: var(--purple); border-color: var(--purple); background: rgba(123,47,247,0.1); }
</style>
</head>
<body>

<!-- ================================================================== -->
<!-- SECTION 1: HERO + NAV                                              -->
<!-- ================================================================== -->
<div class="hero">
  <a href="index.html" class="back-link">&#8592; Back to All Topics</a>
  <h1>Airbnb Group Chat Messaging System</h1>
  <p class="subtitle">Design a group messaging system for hosts, co-hosts, and guests within a booking thread</p>
  <div class="topic-badges">
    <span class="badge badge-medium-hard">Medium-Hard</span>
    <span class="badge badge-red">Core Feature</span>
    <span class="badge badge-green">Data Model Heavy</span>
    <span class="badge badge-blue">Real-Time</span>
    <span class="badge badge-orange">Client Sync</span>
  </div>
  <div class="stats-row">
    <div class="stat-item">
      <div class="stat-value">1M</div>
      <div class="stat-label">DAU</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">50</div>
      <div class="stat-label">Max Group Size</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">5M</div>
      <div class="stat-label">Msgs / Day</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">&#8734;</div>
      <div class="stat-label">Retention</div>
    </div>
  </div>
</div>

<!-- ===== TABLE OF CONTENTS ===== -->
<nav class="toc">
  <h2>Sections</h2>
  <div class="toc-grid">
    <a href="#overview">Overview</a>
    <a href="#requirements">Requirements</a>
    <a href="#capacity">Capacity Estimates</a>
    <a href="#data-model">Data Model</a>
    <a href="#indexes">Indexes &amp; Queries</a>
    <a href="#api">API Design</a>
    <a href="#client-sync">Client-Side Sync</a>
    <a href="#scalability">Scalability</a>
    <a href="#tradeoffs">Trade-offs</a>
    <a href="#interview-tips">Interview Tips</a>
  </div>
  <div class="toggle-controls">
    <button onclick="document.querySelectorAll('.container details').forEach(d=>d.open=true)">Expand All</button>
    <button onclick="document.querySelectorAll('.container details').forEach(d=>d.open=false)">Collapse All</button>
  </div>
</nav>

<div class="container">

<!-- ================================================================== -->
<!-- SECTION 2: OVERVIEW                                                -->
<!-- ================================================================== -->
<section id="overview">
<details open>
  <summary><h2>
    <span class="section-icon" style="background: linear-gradient(135deg, rgba(255,90,95,0.2), rgba(255,90,95,0.15)); color: var(--primary);">&#128172;</span>
    Overview
  </h2></summary>

  <p>Airbnb's messaging system is fundamentally different from a generic chat application. Every conversation is <strong>contextual</strong> -- it is tied to a specific booking, inquiry, or listing interaction between a host (plus optional co-hosts) and a group of guests. A single thread may involve 2 to 50 participants: one host, several co-hosts who manage the property, and a group of guests traveling together.</p>

  <p>The core interview challenge is designing a data model that efficiently supports <strong>group membership</strong>, <strong>inbox queries</strong>, <strong>message ordering</strong>, and <strong>duplicate thread prevention</strong> -- all at scale with messages persisted forever.</p>

  <h3>Key Clarifying Questions</h3>
  <div class="card-grid">
    <div class="card">
      <h4>&#127919; Scope Questions</h4>
      <ul>
        <li><strong>Is this 1:1 or group?</strong> -- Group. Up to 50 users per thread.</li>
        <li><strong>Are threads tied to bookings?</strong> -- Yes, threads can have polymorphic attachments (booking, special offer, inquiry, etc.).</li>
        <li><strong>Can the same group of people have multiple threads?</strong> -- No. If the exact same participant set exists, we resume that thread (dedup by participant hash).</li>
        <li><strong>Do messages expire?</strong> -- No. Messages are persisted forever.</li>
        <li><strong>Do we need real-time delivery?</strong> -- Yes. Push notifications + WebSocket for online users.</li>
        <li><strong>What about read receipts?</strong> -- Per-user read state tracked via flags in user_threads.</li>
      </ul>
    </div>
    <div class="card">
      <h4>&#128200; Scale Questions</h4>
      <ul>
        <li><strong>How many DAU?</strong> -- ~1 million daily active users.</li>
        <li><strong>Messages per user per day?</strong> -- Average ~5 messages/day across threads.</li>
        <li><strong>Inbox size?</strong> -- Default paginated view of 20 threads per page.</li>
        <li><strong>Peak traffic?</strong> -- 3-4x average during booking season.</li>
        <li><strong>Global distribution?</strong> -- Yes, multi-region with eventual consistency acceptable for messages.</li>
        <li><strong>Offline support?</strong> -- Yes, clients must sync missed messages when coming online.</li>
      </ul>
    </div>
  </div>

</details>
</section>

<!-- ================================================================== -->
<!-- SECTION 3: REQUIREMENTS                                            -->
<!-- ================================================================== -->
<section id="requirements">
<details open>
  <summary><h2>
    <span class="section-icon" style="background: linear-gradient(135deg, rgba(0,166,153,0.2), rgba(0,166,153,0.15)); color: #ffffff;">&#9989;</span>
    Requirements
  </h2></summary>

  <div class="card-grid">
    <div class="card">
      <h4 style="color: var(--primary);">Functional Requirements</h4>
      <ol>
        <li><strong>Create Thread</strong> -- Initialize conversation with 2-50 participants. Attach booking context.</li>
        <li><strong>Send Message</strong> -- Post text/rich message to a thread. Idempotent via client_uuid.</li>
        <li><strong>Inbox View</strong> -- Paginated threads by last activity (top 20). Cursor-based.</li>
        <li><strong>Thread Messages</strong> -- Reverse-chronological cursor pagination within a thread.</li>
        <li><strong>Thread Dedup</strong> -- Find existing thread by exact participant set (SHA-256 hash).</li>
        <li><strong>Read Receipts</strong> -- Per-user read state tracking.</li>
      </ol>
    </div>
    <div class="card">
      <h4 style="color: #1e293b;">Non-Functional Requirements</h4>
      <ol>
        <li><strong>Message Ordering</strong> -- Consistent chronological order within a thread across all clients.</li>
        <li><strong>Real-Time Push</strong> -- Online: WebSocket delivery &lt;200ms. Offline: push notifications.</li>
        <li><strong>Inbox &lt;100ms</strong> -- Top 20 threads with preview must load in &lt;100ms p99.</li>
        <li><strong>Availability</strong> -- 99.9% uptime. Messaging is critical path for bookings.</li>
        <li><strong>Idempotency</strong> -- Duplicate sends must not create duplicate messages.</li>
      </ol>
    </div>
  </div>

  <div class="tip-box info">
    <strong>Interview Insight: Scope carefully.</strong>
    The interviewer wants to see you prioritize. Focus on the data model first (Part 1), then client sync (Part 2), then scalability (Part 3). Do NOT jump to WebSockets or caching before you have the tables and indexes right. The data model is where candidates pass or fail this question.
  </div>
</details>
</section>

<!-- ================================================================== -->
<!-- SECTION 4: CAPACITY ESTIMATES                                      -->
<!-- ================================================================== -->
<section id="capacity">
<details>
  <summary><h2>
    <span class="section-icon" style="background: linear-gradient(135deg, rgba(252,100,45,0.2), rgba(252,100,45,0.08)); color: var(--accent);">&#128202;</span>
    Capacity Estimates
  </h2></summary>

  <div class="table-wrap">
    <table>
      <thead>
        <tr>
          <th>Metric</th>
          <th>Value</th>
          <th>Derivation</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Daily Active Users (DAU)</strong></td>
          <td>1,000,000</td>
          <td>Given constraint</td>
        </tr>
        <tr>
          <td><strong>Messages per user per day</strong></td>
          <td>~5</td>
          <td>Airbnb is transactional, not social chat</td>
        </tr>
        <tr>
          <td><strong>Total messages per day</strong></td>
          <td>5,000,000</td>
          <td>1M DAU x 5 msg/user</td>
        </tr>
        <tr>
          <td><strong>Messages per second (avg)</strong></td>
          <td>~58 msg/sec</td>
          <td>5M / 86,400 sec</td>
        </tr>
        <tr>
          <td><strong>Messages per second (peak)</strong></td>
          <td>~200 msg/sec</td>
          <td>3-4x average during peak hours</td>
        </tr>
        <tr>
          <td><strong>Average message size</strong></td>
          <td>~1 KB</td>
          <td>Text body + metadata + indexes overhead</td>
        </tr>
        <tr>
          <td><strong>Daily storage (messages)</strong></td>
          <td>5 GB/day</td>
          <td>5M messages x 1 KB</td>
        </tr>
        <tr>
          <td><strong>Annual storage (messages)</strong></td>
          <td>~1.8 TB/year</td>
          <td>5 GB/day x 365 days</td>
        </tr>
        <tr>
          <td><strong>5-year storage (messages)</strong></td>
          <td>~9 TB</td>
          <td>1.8 TB x 5 years (pre-compression)</td>
        </tr>
        <tr>
          <td><strong>Inbox queries per day</strong></td>
          <td>~1,000,000</td>
          <td>~1 inbox load per DAU per day (conservative)</td>
        </tr>
        <tr>
          <td><strong>Inbox QPS (avg)</strong></td>
          <td>~12 queries/sec</td>
          <td>1M / 86,400</td>
        </tr>
        <tr>
          <td><strong>Active threads (estimated)</strong></td>
          <td>~5M</td>
          <td>Avg 5 active threads per user, heavy overlap</td>
        </tr>
        <tr>
          <td><strong>user_threads rows</strong></td>
          <td>~25M active</td>
          <td>5M threads x avg 5 participants</td>
        </tr>
        <tr>
          <td><strong>WebSocket connections (peak)</strong></td>
          <td>~300K</td>
          <td>~30% of DAU online simultaneously</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="tip-box tip">
    <strong>Why these numbers matter:</strong>
    At ~58 msg/sec write throughput and ~12 inbox QPS, this is a <strong>read-moderate, write-moderate</strong> system. It does not require the extreme write throughput of WhatsApp (~100K msg/sec). The critical bottleneck is the <strong>inbox query</strong> -- joining user_threads with threads to get the top-20 most recent conversations with preview, which must complete in &lt;100ms. This drives our index design.
  </div>
</details>
</section>

<!-- ================================================================== -->
<!-- SECTION 5: DATA MODEL (CRITICAL)                                   -->
<!-- ================================================================== -->
<section id="data-model">
<details>
  <summary><h2>
    <span class="section-icon" style="background: linear-gradient(135deg, rgba(123,47,247,0.2), rgba(123,47,247,0.08)); color: var(--purple);">&#128451;</span>
    Data Model
  </h2></summary>

  <div class="tip-box danger">
    <strong>THIS IS THE CRITICAL SECTION.</strong>
    Per the Airbnb interview rubric, the data model is where calibration happens. Getting the tables right is baseline. Getting the indexes right is "Good." Explaining the end-to-end lifecycle through the schema is "Yes." This section makes or breaks the interview.
  </div>

  <h3>Entity-Relationship Overview</h3>
  <div class="diagram">
  +----------+       +---------------+       +----------+
  |  users   |       |    threads    |       | messages |
  |----------|       |---------------|       |----------|
  | user_id  |&lt;--+   | thread_id     |&lt;------| msg_id   |
  | name     |   |   | creator_id    |       | thread_id|
  | email    |   |   | created_at    |       | user_id  |
  | avatar   |   |   | last_modified |       | body     |
  +----------+   |   | flags         |       | type     |
                 |   | metadata      |       | created  |
                 |   +---------------+       +----------+
                 |          |
                 |   +------+------+        +------------------+
                 |   |             |        | thread_part_hash |
                 |   v             v        |------------------|
            +-----------+   +----------+   | thread_id        |
            |user_threads|  |thread_att|   | participant_hash |
            |-----------|   |----------|   +------------------+
            | thread_id |   | thread_id|
            | user_id   |   | att_type |
            | last_msg  |   | att_id   |
            | flags     |   +----------+
            | last_read |
            +-----------+
  </div>

  <h3>Table Definitions</h3>

  <!-- TABLE 1: users -->
  <div class="er-grid">
    <div class="er-table" style="border-color: var(--blue);">
      <div class="er-header" style="color: var(--blue);">&#128100; users</div>
      <div class="er-row"><span class="er-col er-pk">user_id</span><span class="er-type">BIGINT PK</span></div>
      <div class="er-row"><span class="er-col">name</span><span class="er-type">VARCHAR(100)</span></div>
      <div class="er-row"><span class="er-col">email</span><span class="er-type">VARCHAR(255)</span></div>
      <div class="er-row"><span class="er-col">avatar_url</span><span class="er-type">VARCHAR(512)</span></div>
      <div class="er-row"><span class="er-col">role</span><span class="er-type">ENUM(guest,host)</span></div>
      <div class="er-row"><span class="er-col">created_at</span><span class="er-type">TIMESTAMP</span></div>
    </div>

    <!-- TABLE 2: threads -->
    <div class="er-table" style="border-color: var(--primary);">
      <div class="er-header" style="color: var(--primary);">&#128172; threads</div>
      <div class="er-row"><span class="er-col er-pk">thread_id</span><span class="er-type">BIGINT PK</span></div>
      <div class="er-row"><span class="er-col er-fk">creator_user_id</span><span class="er-type">BIGINT FK</span></div>
      <div class="er-row"><span class="er-col">created_at</span><span class="er-type">TIMESTAMP</span></div>
      <div class="er-row"><span class="er-col">last_modified_at</span><span class="er-type">TIMESTAMP</span></div>
      <div class="er-row"><span class="er-col">flags</span><span class="er-type">INT (bitmask)</span></div>
      <div class="er-row"><span class="er-col">metadata_context</span><span class="er-type">JSON</span></div>
    </div>

    <!-- TABLE 3: messages -->
    <div class="er-table" style="border-color: #ffffff;">
      <div class="er-header" style="color: #1e293b;">&#128233; messages</div>
      <div class="er-row"><span class="er-col er-pk">message_id</span><span class="er-type">BIGINT PK</span></div>
      <div class="er-row"><span class="er-col er-fk">thread_id</span><span class="er-type">BIGINT FK</span></div>
      <div class="er-row"><span class="er-col er-fk">user_id</span><span class="er-type">BIGINT FK</span></div>
      <div class="er-row"><span class="er-col">body</span><span class="er-type">TEXT</span></div>
      <div class="er-row"><span class="er-col">message_type</span><span class="er-type">ENUM(text,system,rich)</span></div>
      <div class="er-row"><span class="er-col">created_at</span><span class="er-type">TIMESTAMP</span></div>
      <div class="er-row"><span class="er-col">client_uuid</span><span class="er-type">UUID (idempotency)</span></div>
    </div>

    <!-- TABLE 4: user_threads -->
    <div class="er-table" style="border-color: var(--accent);">
      <div class="er-header" style="color: var(--accent);">&#128101; user_threads</div>
      <div class="er-row"><span class="er-col er-pk">thread_id</span><span class="er-type">BIGINT PK (compound)</span></div>
      <div class="er-row"><span class="er-col er-pk">user_id</span><span class="er-type">BIGINT PK (compound)</span></div>
      <div class="er-row"><span class="er-col">last_message_at</span><span class="er-type">TIMESTAMP</span></div>
      <div class="er-row"><span class="er-col">last_read_message_id</span><span class="er-type">BIGINT</span></div>
      <div class="er-row"><span class="er-col">flags</span><span class="er-type">INT (bitmask)</span></div>
      <div class="er-row"><span class="er-col">role_in_thread</span><span class="er-type">ENUM(host,cohost,guest)</span></div>
      <div class="er-row"><span class="er-col">joined_at</span><span class="er-type">TIMESTAMP</span></div>
    </div>

    <!-- TABLE 5: thread_participant_hashes -->
    <div class="er-table" style="border-color: var(--warning);">
      <div class="er-header" style="color: var(--warning);">&#128273; thread_participant_hashes</div>
      <div class="er-row"><span class="er-col er-pk">thread_id</span><span class="er-type">BIGINT PK</span></div>
      <div class="er-row"><span class="er-col">participant_hash</span><span class="er-type">VARCHAR(64) UNIQUE</span></div>
    </div>

    <!-- TABLE 6: thread_attachments -->
    <div class="er-table" style="border-color: var(--purple);">
      <div class="er-header" style="color: var(--purple);">&#128206; thread_attachments</div>
      <div class="er-row"><span class="er-col er-pk">thread_id</span><span class="er-type">BIGINT PK (compound)</span></div>
      <div class="er-row"><span class="er-col er-pk">attachment_type</span><span class="er-type">VARCHAR(50) PK</span></div>
      <div class="er-row"><span class="er-col">attachment_id</span><span class="er-type">BIGINT</span></div>
      <div class="er-row"><span class="er-col">metadata</span><span class="er-type">JSON</span></div>
      <div class="er-row"><span class="er-col">created_at</span><span class="er-type">TIMESTAMP</span></div>
    </div>
  </div>

  <h3>Why Each Table Exists -- Design Rationale</h3>

  <!-- Rationale 1: Why not user1_id/user2_id -->
  <div class="card" style="border-left: 4px solid var(--danger);">
    <h4 style="color: var(--danger);">&#10060; Why NOT <code>user1_id</code> / <code>user2_id</code> on the threads table?</h4>
    <p>A common mistake in interviews is to add <code>user1_id</code> and <code>user2_id</code> columns directly on the threads table. This is the <strong>1:1 messaging anti-pattern</strong> and fundamentally breaks for group chat:</p>
    <ul>
      <li><strong>Cannot represent N participants</strong> -- With user1_id/user2_id, you can only support 2-person conversations. Airbnb threads have up to 50 participants (host + co-hosts + guests).</li>
      <li><strong>Query complexity explodes</strong> -- To find "all threads for user X," you'd need <code>WHERE user1_id = X OR user2_id = X</code>, which cannot use a single index efficiently.</li>
      <li><strong>No per-user state</strong> -- Where do you store user A's read status vs user B's? You need separate rows per user anyway.</li>
    </ul>
    <p>The correct approach is the <strong>junction table pattern</strong>: the <code>user_threads</code> table creates one row per (thread, user) pair, cleanly supporting N participants with per-user metadata.</p>
  </div>

  <!-- Rationale 2: Why participant_hash -->
  <div class="card" style="border-left: 4px solid var(--warning);">
    <h4 style="color: var(--warning);">&#128273; Why <code>thread_participant_hashes</code>?</h4>
    <p>When a guest opens a conversation with a host about a listing, the system must check: <strong>"Does a thread already exist for exactly this group of participants?"</strong></p>
    <p><strong>Without this table:</strong> You'd need to scan <code>user_threads</code>, group by <code>thread_id</code>, and check if the exact participant set matches &mdash; a full table scan, <strong>O(N)</strong> over all rows. Unacceptable at scale.</p>
    <p><strong>With the participant hash:</strong> Sort the participant IDs, concatenate, and compute <code>SHA-256("101,202,303")</code> &rarr; deterministic hash. Look up the hash via unique index &mdash; <strong>O(1)</strong>. If found, resume the existing thread. If not, create a new one and store the hash.</p>
    <p>This enables the "resume conversation" UX: the system finds an existing thread instead of creating a duplicate. Hash collision risk with SHA-256 over small integer sets is negligible.</p>
  </div>

  <!-- Rationale 3: Why thread_attachments separate -->
  <div class="card" style="border-left: 4px solid var(--purple);">
    <h4 style="color: var(--purple);">&#128206; Why <code>thread_attachments</code> is a separate table?</h4>
    <p>Thread context is <strong>polymorphic</strong> -- a thread can be linked to different entity types:</p>
    <div class="table-wrap">
      <table>
        <thead>
          <tr><th>attachment_type</th><th>attachment_id points to</th><th>Example Use</th></tr>
        </thead>
        <tbody>
          <tr><td><code>booking</code></td><td>bookings.booking_id</td><td>Active reservation discussion</td></tr>
          <tr><td><code>inquiry</code></td><td>inquiries.inquiry_id</td><td>Pre-booking question</td></tr>
          <tr><td><code>special_offer</code></td><td>special_offers.offer_id</td><td>Host sends custom pricing</td></tr>
          <tr><td><code>listing</code></td><td>listings.listing_id</td><td>General listing question</td></tr>
          <tr><td><code>review_request</code></td><td>reviews.review_id</td><td>Post-stay review nudge</td></tr>
          <tr><td><code>resolution</code></td><td>resolutions.resolution_id</td><td>Dispute or cancellation</td></tr>
        </tbody>
      </table>
    </div>
    <p>By keeping this in a separate table with <code>(attachment_type, attachment_id)</code> as a reverse-lookup index, we achieve:</p>
    <ul>
      <li><strong>Extensibility</strong> -- Adding a new attachment type requires zero schema migration. Just insert a new row.</li>
      <li><strong>Multiple attachments per thread</strong> -- A thread can be linked to both a booking AND a special offer simultaneously.</li>
      <li><strong>Reverse lookups</strong> -- "Find the thread for booking #12345" is a fast indexed query.</li>
    </ul>
  </div>

  <!-- Rationale 4: Why flags column -->
  <div class="card" style="border-left: 4px solid var(--blue);">
    <h4 style="color: var(--blue);">&#127991; Why a <code>flags</code> bitmask column on <code>user_threads</code>?</h4>
    <p>Each user has independent state for a thread. User A may have starred and read a thread while user B has it archived and unread. The <code>flags</code> integer on <code>user_threads</code> (not on <code>threads</code>) stores this per-user state efficiently using a bitmask: UNREAD (0x01), STARRED (0x02), ARCHIVED (0x04), ACTION_REQUIRED (0x08), EXPIRED (0x10), MUTED (0x20).</p>
    <p><strong>Advantages:</strong> single column, no schema changes for new flags (just define a new bit), bitwise filter/update operations are atomic with no read-modify-write race conditions. Battle-tested at Facebook, Slack, and Discord.</p>
  </div>

  <!-- Rationale 5: Why message belongs to ONE thread -->
  <div class="card" style="border-left: 4px solid var(--secondary);">
    <h4 style="color: #1e293b;">&#128233; Why does a message belong to exactly ONE thread?</h4>
    <p>Unlike email (where a message can appear in multiple folders), a chat message is <strong>immutably bound</strong> to a single thread. This simplifies everything:</p>
    <ul>
      <li><strong>No many-to-many</strong> -- No need for a <code>thread_messages</code> junction table. The FK is directly on <code>messages</code>.</li>
      <li><strong>Partitioning</strong> -- Messages can be co-located with their thread (shard by thread_id), giving locality for "load thread messages" queries.</li>
      <li><strong>Simpler consistency</strong> -- Deleting a thread means deleting messages from one partition, not tracking references across many.</li>
    </ul>
  </div>
</details>
</section>

<!-- ================================================================== -->
<!-- SECTION 6: INDEXES AND QUERY PERFORMANCE                           -->
<!-- ================================================================== -->
<section id="indexes">
<details>
  <summary><h2>
    <span class="section-icon" style="background: linear-gradient(135deg, rgba(66,139,249,0.2), rgba(66,139,249,0.08)); color: var(--blue);">&#9889;</span>
    Indexes &amp; Query Performance
  </h2></summary>

  <div class="tip-box warning">
    <strong>Interview Critical: Indexes are what separate "Good" from "Strong Yes."</strong>
    You must articulate WHY each index exists and what access pattern it serves. If you cannot explain why <code>(user_id, last_message_at DESC)</code> makes the inbox query O(M) instead of O(N), you will not pass.
  </div>

  <h3>Index Definitions</h3>
  <div class="table-wrap">
    <table>
      <thead>
        <tr>
          <th>Table</th>
          <th>Index</th>
          <th>Columns</th>
          <th>Purpose</th>
          <th>Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>messages</code></td>
          <td><code>idx_messages_thread_time</code></td>
          <td><code>(thread_id, created_at DESC)</code></td>
          <td>Load messages in a thread, paginated</td>
          <td>O(log N + M)</td>
        </tr>
        <tr>
          <td><code>messages</code></td>
          <td><code>idx_messages_idempotency</code></td>
          <td><code>(client_uuid)</code> UNIQUE</td>
          <td>Prevent duplicate message inserts on retry</td>
          <td>O(log N)</td>
        </tr>
        <tr>
          <td><code>user_threads</code></td>
          <td><code>idx_user_inbox</code></td>
          <td><code>(user_id, last_message_at DESC)</code></td>
          <td>Inbox query: top-M most recent threads</td>
          <td>O(log N + M)</td>
        </tr>
        <tr>
          <td><code>user_threads</code></td>
          <td><code>idx_ut_thread_user</code></td>
          <td><code>(thread_id, user_id)</code> PK</td>
          <td>Participant lookup, membership check</td>
          <td>O(log N)</td>
        </tr>
        <tr>
          <td><code>user_threads</code></td>
          <td><code>idx_ut_unread</code></td>
          <td><code>(user_id, flags)</code></td>
          <td>Count unread threads (badge count)</td>
          <td>O(log N + K)</td>
        </tr>
        <tr>
          <td><code>thread_participant_hashes</code></td>
          <td><code>idx_participant_hash</code></td>
          <td><code>(participant_hash)</code> UNIQUE</td>
          <td>Find existing thread for participant group</td>
          <td>O(log N) = O(1)</td>
        </tr>
        <tr>
          <td><code>thread_attachments</code></td>
          <td><code>idx_att_reverse</code></td>
          <td><code>(attachment_type, attachment_id)</code></td>
          <td>Find thread for a booking/offer</td>
          <td>O(log N)</td>
        </tr>
        <tr>
          <td><code>threads</code></td>
          <td><code>idx_threads_modified</code></td>
          <td><code>(last_modified_at DESC)</code></td>
          <td>Admin: recently active threads</td>
          <td>O(log N + M)</td>
        </tr>
      </tbody>
    </table>
  </div>

  <h3>Key Access Patterns &amp; Complexity</h3>

  <div class="card" style="border-left: 4px solid var(--primary);">
    <h4 style="color: var(--primary);">&#9889; Inbox Load (Top 20 Recent Threads)</h4>
    <p>The most critical query. Uses <code>idx_user_inbox (user_id, last_message_at DESC)</code>.</p>
    <ul>
      <li><strong>Access:</strong> Seek to user_id in the B-tree, walk in descending time order, stop after 20 rows. Exclude archived via bitmask filter.</li>
      <li><strong>Complexity:</strong> <strong>O(log U + 20)</strong> where U = user's total threads. Sub-millisecond.</li>
      <li><strong>Message preview:</strong> For each of the 20 threads, fetch the latest message via <code>idx_messages_thread_time</code>. Total: O(20 &times; log M).</li>
    </ul>
    <div class="tip-box tip">
      <strong>Optimization:</strong> Denormalize <code>last_message_body</code> and <code>last_message_sender_name</code> onto <code>user_threads</code>. Trades write amplification (N row updates per message) for single-query inbox reads. At max 50 participants, this is acceptable.
    </div>
  </div>

  <div class="card" style="border-left: 4px solid var(--blue);">
    <h4 style="color: var(--blue);">&#128172; Load Thread Messages (Cursor-Based Pagination)</h4>
    <p>Uses <code>idx_messages_thread_time (thread_id, created_at DESC)</code>.</p>
    <ul>
      <li><strong>Access:</strong> Seek to (thread_id, cursor_timestamp) in the B-tree, scan 50 rows backward.</li>
      <li><strong>Complexity:</strong> <strong>O(log N + 50)</strong>. Sub-millisecond.</li>
      <li><strong>Key point:</strong> Cursor-based pagination (not OFFSET) &mdash; avoids full-scan on deep pages.</li>
    </ul>
  </div>

  <div class="card" style="border-left: 4px solid var(--warning);">
    <h4 style="color: var(--warning);">&#128273; Find Existing Thread by Participant Group</h4>
    <p>Uses <code>idx_participant_hash (participant_hash) UNIQUE</code>.</p>
    <ul>
      <li><strong>Access:</strong> Compute SHA-256 of sorted participant IDs &rarr; single-key lookup on unique index.</li>
      <li><strong>Complexity:</strong> <strong>O(1)</strong>. If found, resume thread. If not, create new.</li>
    </ul>
  </div>

  <div class="card" style="border-left: 4px solid var(--accent);">
    <h4 style="color: var(--accent);">&#9998; Send Message (Write Path)</h4>
    <p>Single transaction with three operations:</p>
    <ol>
      <li><strong>Insert message</strong> into <code>messages</code> table (idempotent via <code>client_uuid</code> unique constraint &mdash; duplicate sends are silently ignored).</li>
      <li><strong>Update thread</strong> <code>last_modified_at</code>.</li>
      <li><strong>Fan-out:</strong> Update all participants' <code>user_threads</code> rows &mdash; set <code>last_message_at</code>, set UNREAD flag for non-senders, clear it for the sender.</li>
    </ol>
    <p><strong>Complexity:</strong> <strong>O(P)</strong> where P = participants (max 50). This is the fan-out-on-write cost, bounded constant.</p>
  </div>

  <div class="tip-box info">
    <strong>Runtime Complexity Summary:</strong>
    <ul style="margin-top: 8px;">
      <li><strong>Inbox load:</strong> O(log U + M) &mdash; effectively constant time</li>
      <li><strong>Thread messages:</strong> O(log N + M) &mdash; sub-millisecond with index</li>
      <li><strong>Find thread by participants:</strong> O(1) via hash lookup</li>
      <li><strong>Send message:</strong> O(P) where P = participants (max 50)</li>
      <li><strong>Mark as read:</strong> O(log N) single row update on (thread_id, user_id) PK</li>
    </ul>
  </div>
</details>
</section>

<!-- ================================================================== -->
<!-- SECTION 7: API DESIGN                                              -->
<!-- ================================================================== -->
<section id="api">
<details>
  <summary><h2>
    <span class="section-icon" style="background: linear-gradient(135deg, rgba(0,166,153,0.2), rgba(0,166,153,0.15)); color: #ffffff;">&#128279;</span>
    API Design
  </h2></summary>

  <!-- API 1: Create Thread -->
  <div class="card">
    <h4 style="color: var(--primary);">POST /v1/threads</h4>
    <p>Creates a new thread or returns existing thread if participant hash matches.</p>
    <pre><code><span class="comment">// Request</span>
{
  <span class="string">"participant_user_ids"</span>: [<span class="number">101</span>, <span class="number">202</span>, <span class="number">303</span>],
  <span class="string">"initial_message"</span>: {
    <span class="string">"body"</span>: <span class="string">"Hi! I have a question about your listing."</span>,
    <span class="string">"client_uuid"</span>: <span class="string">"550e8400-e29b-41d4-a716-446655440000"</span>
  },
  <span class="string">"attachments"</span>: [
    {
      <span class="string">"type"</span>: <span class="string">"booking"</span>,
      <span class="string">"id"</span>: <span class="number">78901</span>
    }
  ],
  <span class="string">"metadata_context"</span>: {
    <span class="string">"listing_id"</span>: <span class="number">45678</span>,
    <span class="string">"check_in"</span>: <span class="string">"2025-07-04"</span>,
    <span class="string">"check_out"</span>: <span class="string">"2025-07-08"</span>
  }
}

<span class="comment">// Response (201 Created or 200 OK if existing)</span>
{
  <span class="string">"thread_id"</span>: <span class="number">500</span>,
  <span class="string">"created"</span>: <span class="keyword">true</span>,  <span class="comment">// false if resumed existing thread</span>
  <span class="string">"participants"</span>: [
    { <span class="string">"user_id"</span>: <span class="number">101</span>, <span class="string">"name"</span>: <span class="string">"Alice"</span>, <span class="string">"role"</span>: <span class="string">"guest"</span> },
    { <span class="string">"user_id"</span>: <span class="number">202</span>, <span class="string">"name"</span>: <span class="string">"Bob"</span>,   <span class="string">"role"</span>: <span class="string">"host"</span> },
    { <span class="string">"user_id"</span>: <span class="number">303</span>, <span class="string">"name"</span>: <span class="string">"Carol"</span>, <span class="string">"role"</span>: <span class="string">"cohost"</span> }
  ],
  <span class="string">"initial_message"</span>: {
    <span class="string">"message_id"</span>: <span class="number">99001</span>,
    <span class="string">"body"</span>: <span class="string">"Hi! I have a question about your listing."</span>,
    <span class="string">"created_at"</span>: <span class="string">"2025-03-15T10:30:00Z"</span>
  }
}</code></pre>
  </div>

  <!-- API 2: Send Message -->
  <div class="card">
    <h4 style="color: #1e293b;">POST /v1/threads/:thread_id/messages</h4>
    <p>Sends a message to an existing thread. Idempotent via <code>client_uuid</code>.</p>
    <pre><code><span class="comment">// Request</span>
{
  <span class="string">"body"</span>: <span class="string">"Yes, July 4th is available! Would you like to book?"</span>,
  <span class="string">"message_type"</span>: <span class="string">"text"</span>,
  <span class="string">"client_uuid"</span>: <span class="string">"660e8400-e29b-41d4-a716-446655440001"</span>
}

<span class="comment">// Response (201 Created)</span>
{
  <span class="string">"message_id"</span>: <span class="number">99002</span>,
  <span class="string">"thread_id"</span>: <span class="number">500</span>,
  <span class="string">"user_id"</span>: <span class="number">202</span>,
  <span class="string">"body"</span>: <span class="string">"Yes, July 4th is available! Would you like to book?"</span>,
  <span class="string">"message_type"</span>: <span class="string">"text"</span>,
  <span class="string">"created_at"</span>: <span class="string">"2025-03-15T10:32:15Z"</span>
}</code></pre>
  </div>

  <!-- API 3: Get Inbox -->
  <div class="card">
    <h4 style="color: var(--blue);">GET /v1/inbox?page=1&amp;size=20&amp;filter=all</h4>
    <p>Returns paginated inbox for the authenticated user. Filters: <code>all</code>, <code>unread</code>, <code>starred</code>, <code>action_required</code>, <code>archived</code>.</p>
    <pre><code><span class="comment">// Response (200 OK)</span>
{
  <span class="string">"threads"</span>: [
    {
      <span class="string">"thread_id"</span>: <span class="number">500</span>,
      <span class="string">"last_message"</span>: {
        <span class="string">"body"</span>: <span class="string">"Yes, July 4th is available! Would you like to book?"</span>,
        <span class="string">"sender_name"</span>: <span class="string">"Bob"</span>,
        <span class="string">"created_at"</span>: <span class="string">"2025-03-15T10:32:15Z"</span>
      },
      <span class="string">"participants"</span>: [
        { <span class="string">"user_id"</span>: <span class="number">202</span>, <span class="string">"name"</span>: <span class="string">"Bob"</span>, <span class="string">"avatar"</span>: <span class="string">"..."</span> },
        { <span class="string">"user_id"</span>: <span class="number">303</span>, <span class="string">"name"</span>: <span class="string">"Carol"</span>, <span class="string">"avatar"</span>: <span class="string">"..."</span> }
      ],
      <span class="string">"unread_count"</span>: <span class="number">2</span>,
      <span class="string">"flags"</span>: { <span class="string">"unread"</span>: <span class="keyword">true</span>, <span class="string">"starred"</span>: <span class="keyword">false</span>, <span class="string">"action_required"</span>: <span class="keyword">true</span> },
      <span class="string">"attachments"</span>: [
        { <span class="string">"type"</span>: <span class="string">"booking"</span>, <span class="string">"id"</span>: <span class="number">78901</span>, <span class="string">"status"</span>: <span class="string">"pending"</span> }
      ]
    }
    <span class="comment">// ... up to 20 threads</span>
  ],
  <span class="string">"pagination"</span>: {
    <span class="string">"page"</span>: <span class="number">1</span>,
    <span class="string">"size"</span>: <span class="number">20</span>,
    <span class="string">"has_more"</span>: <span class="keyword">true</span>,
    <span class="string">"total_unread"</span>: <span class="number">7</span>
  }
}</code></pre>
  </div>

  <!-- API 4: Get Thread Messages -->
  <div class="card">
    <h4 style="color: var(--accent);">GET /v1/threads/:thread_id/messages?before=cursor&amp;limit=50</h4>
    <p>Cursor-based pagination for thread messages. The <code>before</code> cursor is the <code>created_at</code> timestamp of the last message the client has seen.</p>
    <pre><code><span class="comment">// Response (200 OK)</span>
{
  <span class="string">"thread_id"</span>: <span class="number">500</span>,
  <span class="string">"messages"</span>: [
    {
      <span class="string">"message_id"</span>: <span class="number">99002</span>,
      <span class="string">"user_id"</span>: <span class="number">202</span>,
      <span class="string">"sender"</span>: { <span class="string">"name"</span>: <span class="string">"Bob"</span>, <span class="string">"avatar"</span>: <span class="string">"..."</span>, <span class="string">"role"</span>: <span class="string">"host"</span> },
      <span class="string">"body"</span>: <span class="string">"Yes, July 4th is available! Would you like to book?"</span>,
      <span class="string">"message_type"</span>: <span class="string">"text"</span>,
      <span class="string">"created_at"</span>: <span class="string">"2025-03-15T10:32:15Z"</span>
    },
    {
      <span class="string">"message_id"</span>: <span class="number">99001</span>,
      <span class="string">"user_id"</span>: <span class="number">101</span>,
      <span class="string">"sender"</span>: { <span class="string">"name"</span>: <span class="string">"Alice"</span>, <span class="string">"avatar"</span>: <span class="string">"..."</span>, <span class="string">"role"</span>: <span class="string">"guest"</span> },
      <span class="string">"body"</span>: <span class="string">"Hi! I have a question about your listing."</span>,
      <span class="string">"message_type"</span>: <span class="string">"text"</span>,
      <span class="string">"created_at"</span>: <span class="string">"2025-03-15T10:30:00Z"</span>
    }
  ],
  <span class="string">"pagination"</span>: {
    <span class="string">"has_more"</span>: <span class="keyword">false</span>,
    <span class="string">"next_cursor"</span>: <span class="keyword">null</span>
  }
}</code></pre>
  </div>

  <!-- API 5: Mark Thread Read -->
  <div class="card">
    <h4 style="color: var(--purple);">PATCH /v1/threads/:thread_id/read</h4>
    <p>Marks the thread as read for the authenticated user.</p>
    <pre><code><span class="comment">// Request</span>
{
  <span class="string">"last_read_message_id"</span>: <span class="number">99002</span>
}

<span class="comment">// Response (200 OK)</span>
{
  <span class="string">"thread_id"</span>: <span class="number">500</span>,
  <span class="string">"unread_count"</span>: <span class="number">0</span>,
  <span class="string">"last_read_message_id"</span>: <span class="number">99002</span>
}</code></pre>
  </div>
</details>
</section>

<!-- ================================================================== -->
<!-- SECTION 8: CLIENT-SIDE SYNC                                        -->
<!-- ================================================================== -->
<section id="client-sync">
<details>
  <summary><h2>
    <span class="section-icon" style="background: linear-gradient(135deg, rgba(252,100,45,0.2), rgba(252,100,45,0.08)); color: var(--accent);">&#128241;</span>
    Client-Side Sync
  </h2></summary>

  <p>When a user opens the Airbnb app after being offline, the client needs to efficiently sync all missed messages and thread state changes. There are two fundamental approaches, and choosing between them is a key interview differentiator.</p>

  <h3>Approach A: Pull-Based Sync</h3>
  <div class="card" style="border-top: 3px solid var(--blue);">
    <h4 style="color: var(--blue);">Pull Mode: Client Sends last_updated_at</h4>
    <div class="diagram">
  Client                              Server
    |                                    |
    |--- GET /sync?since=2025-03-14T..  |
    |                                    |
    |    Query: SELECT * FROM user_threads
    |    WHERE user_id = 101
    |      AND last_message_at > '2025-03-14T...'
    |    ORDER BY last_message_at DESC
    |                                    |
    |<-- { updated_threads: [...],       |
    |      new_messages: [...] }         |
    |                                    |
    </div>
    <p><strong>How it works:</strong></p>
    <ol>
      <li>Client stores <code>last_sync_timestamp</code> locally.</li>
      <li>On reconnect, client sends <code>GET /sync?since={last_sync_timestamp}</code>.</li>
      <li>Server queries <code>user_threads</code> using the <code>(user_id, last_message_at)</code> index to find all threads modified since that timestamp.</li>
      <li>For each changed thread, server fetches new messages since the client's <code>last_read_message_id</code>.</li>
      <li>Server returns the diff payload.</li>
    </ol>
    <div class="table-wrap">
      <table>
        <tr><th>Pros</th><th>Cons</th></tr>
        <tr>
          <td>
            <ul>
              <li>Simple write path -- no fan-out table needed</li>
              <li>Uses existing <code>user_threads</code> index</li>
              <li>No storage overhead for per-device state</li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Read-heavy: every sync scans user_threads</li>
              <li>If user has many threads, sync query can be expensive</li>
              <li>Timestamp-based: clock skew can cause missed messages</li>
            </ul>
          </td>
        </tr>
      </table>
    </div>
  </div>

  <h3>Approach B: Push-Based Sync (Fan-Out Table)</h3>
  <div class="card" style="border-top: 3px solid var(--secondary);">
    <h4 style="color: #1e293b;">Push Mode: Server Maintains user_messages Fan-Out Table</h4>
    <div class="diagram">
  When message is sent to thread with participants [101, 202, 303]:

  Write path fans out to user_messages table:
  +---------------------------------------------------+
  | user_messages                                      |
  |---------------------------------------------------|
  | user_id | message_id | thread_id | created_at     |
  |---------|------------|-----------|----------------|
  |   101   |   99002    |    500    | 2025-03-15 ... |
  |   202   |   99002    |    500    | 2025-03-15 ... |
  |   303   |   99002    |    500    | 2025-03-15 ... |
  +---------------------------------------------------+

  Client sync:
  GET /sync?last_message_id=99001

  Server query:
  SELECT * FROM user_messages
  WHERE user_id = 101 AND message_id > 99001
  ORDER BY message_id ASC;
    </div>
    <p><strong>How it works:</strong></p>
    <ol>
      <li>When a message is sent, the server writes one row per participant into the <code>user_messages</code> fan-out table.</li>
      <li>Client stores the <code>max_message_id</code> it has seen.</li>
      <li>On reconnect, client sends <code>GET /sync?last_message_id={max_id}</code>.</li>
      <li>Server queries <code>user_messages WHERE user_id = X AND message_id > max_id</code>.</li>
      <li>Since <code>message_id</code> is monotonically increasing, there is no clock skew problem.</li>
    </ol>
    <div class="table-wrap">
      <table>
        <tr><th>Pros</th><th>Cons</th></tr>
        <tr>
          <td>
            <ul>
              <li>Sync is a simple range scan on (user_id, message_id)</li>
              <li>No clock skew issues -- uses monotonic IDs</li>
              <li>Granular: knows exactly which messages were missed</li>
              <li>Can support per-device tracking</li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Write amplification: 1 message creates P rows (up to 50)</li>
              <li>Additional storage: ~50x message storage overhead</li>
              <li>user_messages table grows very fast (250M rows/day at scale)</li>
              <li>Need TTL/compaction to manage size</li>
            </ul>
          </td>
        </tr>
      </table>
    </div>
  </div>

  <h3>Real-Time Delivery: WebSocket Layer</h3>
  <div class="card">
    <h4 style="color: var(--accent);">WebSocket Connection Management</h4>
    <div class="diagram">
  Guest's Phone          WebSocket Gateway          Message Service
       |                       |                          |
       |--- WS Connect -----&gt; |                          |
       |    (auth token)       |-- Register:              |
       |                       |   device_101 -&gt; ws_conn  |
       |                       |   (in-memory map)        |
       |                       |                          |
       |                       |                          |
       |                       | &lt;-- New message event ---|
       |                       |    {thread:500, msg:99002}
       |                       |                          |
       |                       |-- Lookup: who is online  |
       |                       |   in thread 500?         |
       |                       |   [user_101: connected,  |
       |                       |    user_202: connected,  |
       |                       |    user_303: offline]    |
       |                       |                          |
       | &lt;-- WS Push ---------|                          |
       |    {new_message: ...} |                          |
       |                       |-- Push notification -----|
       |                       |   to user_303 (offline)  |
       |                       |   via APNs/FCM           |
    </div>
    <p><strong>Device Connection State:</strong></p>
    <ul>
      <li>The WebSocket gateway maintains an in-memory map: <code>user_id -> [ws_connection_1, ws_connection_2, ...]</code> (multi-device).</li>
      <li>When a new message arrives, the message service publishes an event. The gateway looks up all online participants and pushes to their connections.</li>
      <li>For offline users, a notification job enqueues push notifications (APNs for iOS, FCM for Android).</li>
      <li>Each device tracks its own <code>last_seen_message_id</code> so sync works per-device.</li>
    </ul>
  </div>

  <div class="tip-box purple">
    <strong>Interview Recommendation:</strong>
    Start with Pull-based sync as the default (simpler, fewer writes). Then mention Push-based as an optimization for users with many threads or for per-device sync. The interviewer wants to see that you understand both patterns and can articulate the trade-offs. WebSocket is the real-time layer on TOP of either sync approach -- it does not replace sync.
  </div>
</details>
</section>

<!-- ================================================================== -->
<!-- SECTION 9: SCALABILITY                                             -->
<!-- ================================================================== -->
<section id="scalability">
<details>
  <summary><h2>
    <span class="section-icon" style="background: linear-gradient(135deg, rgba(16,185,129,0.2), rgba(16,185,129,0.06)); color: var(--success);">&#128640;</span>
    Scalability
  </h2></summary>

  <h3>Sharding Strategy</h3>
  <div class="table-wrap">
    <table>
      <thead>
        <tr>
          <th>Table</th>
          <th>Shard Key</th>
          <th>Rationale</th>
          <th>Trade-off</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>users</code></td>
          <td><code>user_id</code></td>
          <td>Natural key, even distribution with hash-based sharding</td>
          <td>None -- clean partition</td>
        </tr>
        <tr>
          <td><code>threads</code></td>
          <td><code>thread_id</code></td>
          <td>Each thread is self-contained metadata</td>
          <td>None -- clean partition</td>
        </tr>
        <tr>
          <td><code>messages</code></td>
          <td><code>thread_id</code></td>
          <td>Co-locates all messages for a thread on same shard. "Load thread messages" is single-shard.</td>
          <td>Hot threads (viral group chats) can create hot spots. Mitigate with read replicas.</td>
        </tr>
        <tr>
          <td><code>user_threads</code></td>
          <td style="color: var(--warning);"><strong>user_id (TRICKY)</strong></td>
          <td>Inbox query needs all threads for a user on one shard</td>
          <td>See detailed analysis below</td>
        </tr>
        <tr>
          <td><code>thread_participant_hashes</code></td>
          <td><code>participant_hash</code></td>
          <td>Hash lookup is single-key, any shard strategy works</td>
          <td>None -- simple lookup table</td>
        </tr>
        <tr>
          <td><code>thread_attachments</code></td>
          <td><code>thread_id</code></td>
          <td>Co-locate with threads table</td>
          <td>Reverse lookup (by attachment_id) requires scatter-gather or secondary index</td>
        </tr>
      </tbody>
    </table>
  </div>

  <h3>The user_threads Sharding Dilemma</h3>
  <div class="card" style="border-left: 4px solid var(--warning);">
    <h4 style="color: var(--warning);">&#9888; Why user_threads is the hardest table to shard</h4>
    <p>The <code>user_threads</code> table serves TWO access patterns with conflicting shard key requirements:</p>

    <div class="compare-grid">
      <div class="compare-card pull">
        <h4 style="color: var(--blue);">Shard by user_id</h4>
        <p><strong>Inbox query (fast):</strong> All of user X's threads are on one shard. <code>SELECT ... WHERE user_id = X ORDER BY last_message_at DESC</code> is single-shard.</p>
        <p><strong>Participant lookup (slow):</strong> "Who is in thread 500?" requires scatter-gather across ALL shards, because participants of thread 500 are distributed across user shards.</p>
        <p style="color: var(--success);"><strong>Winner for: READ (inbox)</strong></p>
      </div>
      <div class="compare-card push">
        <h4 style="color: #1e293b;">Shard by thread_id</h4>
        <p><strong>Participant lookup (fast):</strong> All participants of thread 500 are on one shard. Easy to update all rows when a message arrives.</p>
        <p><strong>Inbox query (slow):</strong> "What are user X's recent threads?" requires scatter-gather across ALL shards, because user X's threads are distributed across thread shards.</p>
        <p style="color: var(--success);"><strong>Winner for: WRITE (fan-out updates)</strong></p>
      </div>
    </div>

    <div class="tip-box tip">
      <strong>Solution: Shard by user_id + compensate with thread_participant_hashes.</strong>
      <p style="margin-top: 8px;">Since inbox load is the higher-frequency, latency-sensitive operation, shard <code>user_threads</code> by <code>user_id</code>. For the "who is in this thread?" query (needed when sending a message), use the <code>thread_participant_hashes</code> table to find the thread, then look up participants via a secondary cross-shard query -- OR -- maintain a denormalized <code>thread_participants</code> cache (Redis set per thread_id) that is updated on thread creation and participant changes.</p>
      <p style="margin-top: 8px;">Alternatively, when sending a message, the <strong>message service already knows the thread_id</strong>. It can query <code>user_threads WHERE thread_id = X</code> with a scatter-gather. Since this is a write-path operation (not user-facing latency), the scatter-gather cost is acceptable (~50ms across shards).</p>
    </div>
  </div>

  <h3>Caching Strategy</h3>
  <div class="card-grid">
    <div class="card">
      <h4 style="color: #1e293b;">&#9889; Redis Cache Layer</h4>
      <ul>
        <li><strong>Inbox cache:</strong> <code>inbox:{user_id}</code> -- Sorted set of (thread_id, last_message_at) for active users. TTL: 30 min. Invalidated on new message.</li>
        <li><strong>Thread participants:</strong> <code>participants:{thread_id}</code> -- Set of user_ids. No TTL (changes rarely). Used for fan-out without DB query.</li>
        <li><strong>User profile:</strong> <code>user:{user_id}</code> -- Name, avatar. Used for message rendering. TTL: 1 hour.</li>
        <li><strong>Unread count:</strong> <code>unread:{user_id}</code> -- Integer counter for badge. Atomic increment/decrement. Invalidated on read.</li>
      </ul>
    </div>
    <div class="card">
      <h4 style="color: var(--accent);">&#128200; Cache Hit Rates</h4>
      <ul>
        <li><strong>Inbox cache:</strong> ~85% hit rate for active users (most users check inbox multiple times per session).</li>
        <li><strong>Thread participants:</strong> ~95% hit rate (participants change very rarely).</li>
        <li><strong>User profiles:</strong> ~90% hit rate (same users appear repeatedly in threads).</li>
        <li><strong>Write-through pattern:</strong> On new message, update cache directly instead of invalidating. Avoids cache stampede.</li>
      </ul>
    </div>
  </div>

  <h3>Message Archival &amp; Partitioning</h3>
  <div class="card">
    <h4 style="color: var(--purple);">&#128451; Time-Based Partitioning for Messages</h4>
    <p>Since messages are persisted forever but recent messages are accessed 100x more frequently than old ones:</p>
    <ul>
      <li><strong>Hot partition (0-6 months):</strong> MySQL/PostgreSQL on SSD. Full indexes. Serves 99% of reads.</li>
      <li><strong>Warm partition (6-24 months):</strong> MySQL on HDD or Cassandra. Reduced indexes. Serves occasional scroll-back.</li>
      <li><strong>Cold partition (24+ months):</strong> Compressed in S3/Glacier with a thin query layer. Loaded on-demand.</li>
      <li><strong>Partition key:</strong> <code>(thread_id, YEAR_MONTH(created_at))</code> -- Keeps thread locality while enabling time-based pruning.</li>
    </ul>
    <p>Migration is automated: a daily job moves partitions older than the threshold to the next tier. The query layer transparently routes queries to the correct tier based on the cursor timestamp.</p>
  </div>

  <h3>High-Level Architecture</h3>
  <div class="diagram-box">
<svg viewBox="0 0 1100 680" xmlns="http://www.w3.org/2000/svg" font-family="'Segoe UI', sans-serif" style="width:100%; height:auto;">
  <defs>
    <!-- Gradients -->
    <linearGradient id="g1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#FF5A5F"/><stop offset="100%" stop-color="#FF8A8E"/></linearGradient>
    <linearGradient id="g2" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#00A699"/><stop offset="100%" stop-color="#33C1B5"/></linearGradient>
    <linearGradient id="g3" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#428BF9"/><stop offset="100%" stop-color="#72ABFF"/></linearGradient>
    <linearGradient id="g4" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#7B2FF7"/><stop offset="100%" stop-color="#A66FFF"/></linearGradient>
    <linearGradient id="g5" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#FC642D"/><stop offset="100%" stop-color="#FF9966"/></linearGradient>
    <!-- Shadow -->
    <filter id="shadow"><feDropShadow dx="2" dy="3" stdDeviation="4" flood-opacity="0.12"/></filter>
    <!-- Arrow markers -->
    <marker id="arrowSync" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="10" markerHeight="7" orient="auto-start-reverse"><polygon points="0 0, 10 3.5, 0 7" fill="#9ca3af"/></marker>
    <marker id="arrowAsync" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="10" markerHeight="7" orient="auto-start-reverse"><polygon points="0 0, 10 3.5, 0 7" fill="#ef4444"/></marker>
    <marker id="arrowBi" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="10" markerHeight="7" orient="auto-start-reverse"><polygon points="0 0, 10 3.5, 0 7" fill="#facc15"/></marker>
  </defs>

  <!-- Section Labels -->
  <text x="80" y="28" fill="#fff" font-size="13" font-weight="700" letter-spacing="2">CLIENTS</text>
  <text x="350" y="28" fill="#fff" font-size="13" font-weight="700" letter-spacing="2">GATEWAY</text>
  <text x="590" y="28" fill="#fff" font-size="13" font-weight="700" letter-spacing="2">SERVICES</text>
  <text x="910" y="28" fill="#fff" font-size="13" font-weight="700" letter-spacing="2">DATA LAYER</text>

  <!-- ======= CLIENTS ======= -->
  <!-- Web Client (monitor icon) -->
  <g filter="url(#shadow)">
    <rect x="30" y="100" width="120" height="70" rx="10" fill="url(#g3)" opacity="0.92"/>
    <!-- Monitor icon -->
    <rect x="65" y="112" width="30" height="22" rx="3" fill="none" stroke="#fff" stroke-width="1.8"/>
    <line x1="80" y1="134" x2="80" y2="140" stroke="#fff" stroke-width="1.8"/>
    <line x1="72" y1="140" x2="88" y2="140" stroke="#fff" stroke-width="1.8"/>
    <text x="90" y="152" fill="#fff" font-size="12" font-weight="600">Web</text>
  </g>

  <!-- Mobile Client (phone icon) -->
  <g filter="url(#shadow)">
    <rect x="30" y="210" width="120" height="70" rx="10" fill="url(#g3)" opacity="0.92"/>
    <!-- Phone icon -->
    <rect x="72" y="222" width="16" height="26" rx="3" fill="none" stroke="#fff" stroke-width="1.8"/>
    <line x1="77" y1="243" x2="83" y2="243" stroke="#fff" stroke-width="1.5"/>
    <text x="90" y="262" fill="#fff" font-size="12" font-weight="600">Mobile</text>
  </g>

  <!-- ======= GATEWAY ======= -->
  <!-- Load Balancer -->
  <g filter="url(#shadow)">
    <rect x="230" y="140" width="140" height="58" rx="10" fill="#161b22" stroke="#10b981" stroke-width="2"/>
    <!-- LB icon: line splitting into two -->
    <line x1="260" y1="169" x2="275" y2="169" stroke="#10b981" stroke-width="2.2"/>
    <line x1="275" y1="169" x2="290" y2="157" stroke="#10b981" stroke-width="2.2"/>
    <line x1="275" y1="169" x2="290" y2="181" stroke="#10b981" stroke-width="2.2"/>
    <circle cx="292" cy="157" r="2.5" fill="#10b981"/>
    <circle cx="292" cy="181" r="2.5" fill="#10b981"/>
    <text x="300" y="173" fill="#d1d5db" font-size="11" font-weight="600">Load Balancer</text>
  </g>

  <!-- API Gateway (shield) -->
  <g filter="url(#shadow)">
    <rect x="230" y="230" width="140" height="68" rx="10" fill="#161b22" stroke="#FF5A5F" stroke-width="2"/>
    <!-- Shield icon -->
    <path d="M262,248 L262,262 Q262,272 272,276 Q282,272 282,262 L282,248 L272,244 Z" fill="none" stroke="#FF5A5F" stroke-width="1.8"/>
    <!-- Checkmark inside shield -->
    <polyline points="266,258 270,263 278,253" fill="none" stroke="#FF5A5F" stroke-width="1.8"/>
    <text x="290" y="263" fill="#d1d5db" font-size="11" font-weight="600">API Gateway</text>
    <text x="290" y="278" fill="#9ca3af" font-size="9">Auth + Rate Limit</text>
  </g>

  <!-- ======= SERVICES ======= -->
  <!-- Chat Service (speech bubble) -->
  <g filter="url(#shadow)">
    <rect x="460" y="55" width="155" height="65" rx="10" fill="url(#g1)" opacity="0.9"/>
    <!-- Speech bubble icon -->
    <rect x="478" y="68" width="22" height="16" rx="5" fill="none" stroke="#fff" stroke-width="1.6"/>
    <polygon points="484,84 488,90 492,84" fill="none" stroke="#fff" stroke-width="1.4"/>
    <text x="506" y="82" fill="#fff" font-size="11" font-weight="600">Chat Service</text>
    <text x="506" y="95" fill="rgba(255,255,255,0.75)" font-size="9">Send / Receive msgs</text>
  </g>

  <!-- Inbox Service (envelope) -->
  <g filter="url(#shadow)">
    <rect x="460" y="145" width="155" height="65" rx="10" fill="url(#g2)" opacity="0.9"/>
    <!-- Envelope icon -->
    <rect x="478" y="160" width="22" height="15" rx="2" fill="none" stroke="#fff" stroke-width="1.6"/>
    <polyline points="478,160 489,170 500,160" fill="none" stroke="#fff" stroke-width="1.4"/>
    <text x="506" y="174" fill="#fff" font-size="11" font-weight="600">Inbox Service</text>
    <text x="506" y="187" fill="rgba(255,255,255,0.75)" font-size="9">Thread list + previews</text>
  </g>

  <!-- Sync Service (arrows) -->
  <g filter="url(#shadow)">
    <rect x="460" y="235" width="155" height="65" rx="10" fill="url(#g4)" opacity="0.9"/>
    <!-- Sync arrows icon -->
    <path d="M482,260 L496,260" stroke="#fff" stroke-width="1.6" marker-end="url(#arrowBi)"/>
    <path d="M496,274 L482,274" stroke="#fff" stroke-width="1.6" marker-end="url(#arrowBi)"/>
    <text x="506" y="264" fill="#fff" font-size="11" font-weight="600">Sync Service</text>
    <text x="506" y="277" fill="rgba(255,255,255,0.75)" font-size="9">Client state sync</text>
  </g>

  <!-- Notification Service (bell) -->
  <g filter="url(#shadow)">
    <rect x="460" y="325" width="155" height="65" rx="10" fill="url(#g5)" opacity="0.9"/>
    <!-- Bell icon -->
    <path d="M486,342 Q486,334 493,334 Q500,334 500,342 L502,350 L484,350 Z" fill="none" stroke="#fff" stroke-width="1.6"/>
    <circle cx="493" cy="354" r="2.5" fill="#fff"/>
    <text x="506" y="356" fill="#fff" font-size="11" font-weight="600">Notification Svc</text>
    <text x="506" y="369" fill="rgba(255,255,255,0.75)" font-size="9">Push / Email / SMS</text>
  </g>

  <!-- ======= REAL-TIME ======= -->
  <!-- WebSocket Server (lightning bolt) -->
  <g filter="url(#shadow)">
    <rect x="230" y="380" width="155" height="65" rx="10" fill="#161b22" stroke="#facc15" stroke-width="2"/>
    <!-- Lightning bolt -->
    <polygon points="264,390 258,407 266,407 260,424 274,402 266,402 272,390" fill="#facc15" opacity="0.9"/>
    <text x="282" y="408" fill="#facc15" font-size="11" font-weight="700">WebSocket Server</text>
    <text x="282" y="422" fill="#9ca3af" font-size="9">Real-time delivery</text>
  </g>

  <!-- ======= DATA LAYER ======= -->
  <!-- PostgreSQL Cylinder -->
  <g filter="url(#shadow)">
    <ellipse cx="808" cy="82" rx="55" ry="14" fill="#3a78d6" stroke="#428BF9" stroke-width="1.5"/>
    <rect x="753" y="82" width="110" height="100" fill="#3a78d6" stroke="none"/>
    <ellipse cx="808" cy="182" rx="55" ry="14" fill="#2e62b0" stroke="#428BF9" stroke-width="1.5"/>
    <line x1="753" y1="82" x2="753" y2="182" stroke="#428BF9" stroke-width="1.5"/>
    <line x1="863" y1="82" x2="863" y2="182" stroke="#428BF9" stroke-width="1.5"/>
    <text x="808" y="108" text-anchor="middle" fill="#fff" font-size="12" font-weight="700">PostgreSQL</text>
    <text x="808" y="124" text-anchor="middle" fill="rgba(255,255,255,0.9)" font-size="9">threads</text>
    <text x="808" y="137" text-anchor="middle" fill="rgba(255,255,255,0.9)" font-size="9">messages</text>
    <text x="808" y="150" text-anchor="middle" fill="rgba(255,255,255,0.9)" font-size="9">user_threads</text>
    <text x="808" y="163" text-anchor="middle" fill="rgba(255,255,255,0.9)" font-size="9">participant_hashes</text>
    <text x="808" y="176" text-anchor="middle" fill="rgba(255,255,255,0.9)" font-size="9">attachments</text>
  </g>

  <!-- Redis Diamond -->
  <g filter="url(#shadow)">
    <polygon points="945,120 1000,170 945,220 890,170" fill="#1a1a2e" stroke="#ef4444" stroke-width="2"/>
    <polygon points="945,138 985,170 945,202 905,170" fill="#2a1015" stroke="#ef4444" stroke-width="1" opacity="0.7"/>
    <text x="945" y="162" text-anchor="middle" fill="#ef4444" font-size="12" font-weight="700">Redis</text>
    <text x="945" y="176" text-anchor="middle" fill="#fca5a5" font-size="8">inbox cache</text>
    <text x="945" y="187" text-anchor="middle" fill="#fca5a5" font-size="8">online presence</text>
    <text x="945" y="198" text-anchor="middle" fill="#fca5a5" font-size="8">unread counts</text>
  </g>

  <!-- Kafka Cluster -->
  <g filter="url(#shadow)">
    <rect x="860" y="280" width="150" height="120" rx="10" fill="#161b22" stroke="#ef4444" stroke-width="1.5"/>
    <!-- Kafka nodes -->
    <circle cx="900" cy="315" r="10" fill="#ef4444" opacity="0.85"/>
    <circle cx="935" cy="300" r="10" fill="#ef4444" opacity="0.85"/>
    <circle cx="970" cy="315" r="10" fill="#ef4444" opacity="0.85"/>
    <!-- Connecting lines between nodes -->
    <line x1="910" y1="315" x2="925" y2="302" stroke="#fca5a5" stroke-width="1.2"/>
    <line x1="945" y1="302" x2="960" y2="315" stroke="#fca5a5" stroke-width="1.2"/>
    <line x1="910" y1="315" x2="960" y2="315" stroke="#fca5a5" stroke-width="1.2"/>
    <!-- Streaming arrows -->
    <path d="M895,340 L965,340" stroke="#fca5a5" stroke-width="1" stroke-dasharray="4,3"/>
    <path d="M895,352 L965,352" stroke="#fca5a5" stroke-width="1" stroke-dasharray="4,3"/>
    <path d="M895,364 L965,364" stroke="#fca5a5" stroke-width="1" stroke-dasharray="4,3"/>
    <polygon points="965,337 972,340 965,343" fill="#fca5a5"/>
    <polygon points="965,349 972,352 965,355" fill="#fca5a5"/>
    <polygon points="965,361 972,364 965,367" fill="#fca5a5"/>
    <text x="935" y="386" text-anchor="middle" fill="#ef4444" font-size="12" font-weight="700">KAFKA</text>
    <text x="935" y="396" text-anchor="middle" fill="#fca5a5" font-size="8">msg events / sync / push</text>
  </g>

  <!-- ======= CONNECTION LINES ======= -->
  <!-- Clients to Load Balancer -->
  <line x1="150" y1="135" x2="230" y2="160" stroke="#9ca3af" stroke-width="1.5" marker-end="url(#arrowSync)"/>
  <line x1="150" y1="245" x2="230" y2="178" stroke="#9ca3af" stroke-width="1.5" marker-end="url(#arrowSync)"/>

  <!-- LB to API Gateway -->
  <line x1="300" y1="198" x2="300" y2="230" stroke="#9ca3af" stroke-width="1.5" marker-end="url(#arrowSync)"/>

  <!-- API GW to Chat Service -->
  <line x1="370" y1="254" x2="460" y2="90" stroke="#9ca3af" stroke-width="1.5" marker-end="url(#arrowSync)"/>
  <!-- API GW to Inbox Service -->
  <line x1="370" y1="264" x2="460" y2="177" stroke="#9ca3af" stroke-width="1.5" marker-end="url(#arrowSync)"/>

  <!-- Client <-> WebSocket (bidirectional, yellow) -->
  <line x1="90" y1="280" x2="230" y2="400" stroke="#facc15" stroke-width="2" marker-end="url(#arrowBi)" marker-start="url(#arrowBi)"/>
  <text x="130" y="345" fill="#facc15" font-size="8" transform="rotate(-30,130,345)">bidirectional</text>

  <!-- WebSocket to Chat Service -->
  <line x1="385" y1="395" x2="460" y2="105" stroke="#facc15" stroke-width="1.2" stroke-dasharray="6,3" marker-end="url(#arrowAsync)"/>

  <!-- Chat Service to PostgreSQL -->
  <line x1="615" y1="87" x2="753" y2="120" stroke="#9ca3af" stroke-width="1.5" marker-end="url(#arrowSync)"/>

  <!-- Chat Service to Redis -->
  <line x1="615" y1="80" x2="890" y2="155" stroke="#9ca3af" stroke-width="1.5" marker-end="url(#arrowSync)"/>

  <!-- Chat Service to Kafka (async - dashed) -->
  <line x1="615" y1="100" x2="860" y2="320" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="6,3" marker-end="url(#arrowAsync)"/>

  <!-- Inbox Service to Redis -->
  <line x1="615" y1="170" x2="890" y2="170" stroke="#9ca3af" stroke-width="1.5" marker-end="url(#arrowSync)"/>
  <text x="740" y="164" fill="#9ca3af" font-size="8">cache hit</text>

  <!-- Inbox Service to PostgreSQL (cache miss) -->
  <line x1="615" y1="180" x2="753" y2="150" stroke="#9ca3af" stroke-width="1.3" stroke-dasharray="4,3" marker-end="url(#arrowSync)"/>
  <text x="665" y="172" fill="#9ca3af" font-size="8">cache miss</text>

  <!-- Kafka to Notification Service (async) -->
  <line x1="860" y1="360" x2="615" y2="357" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="6,3" marker-end="url(#arrowAsync)"/>

  <!-- Kafka to Sync Service (async) -->
  <line x1="860" y1="340" x2="615" y2="267" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="6,3" marker-end="url(#arrowAsync)"/>

  <!-- ======= NUMBERED STEP CIRCLES ======= -->
  <!-- Step 1: Client -> WebSocket Server (WSS) -->
  <circle cx="155" cy="340" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="155" y="344" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">1</text>
  <!-- Step 2: Client -> API Gateway (HTTPS) -->
  <circle cx="190" cy="148" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="190" y="152" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">2</text>
  <!-- Step 3: API Gateway -> Chat Service (gRPC) -->
  <circle cx="415" cy="170" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="415" y="174" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">3</text>
  <!-- Step 4: Chat Service -> PostgreSQL -->
  <circle cx="684" cy="104" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="684" y="108" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">4</text>
  <!-- Step 5: Chat Service -> Redis -->
  <circle cx="752" cy="118" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="752" y="122" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">5</text>
  <!-- Step 6: Chat Service -> Kafka -->
  <circle cx="738" cy="210" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="738" y="214" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">6</text>
  <!-- Step 7: Kafka -> WebSocket Server (consumer) -->
  <circle cx="738" cy="304" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="738" y="308" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">7</text>
  <!-- Step 8: Kafka -> Notification Service (consumer) -->
  <circle cx="738" cy="359" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="738" y="363" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">8</text>
  <!-- Step 9: Client -> API GW -> Inbox Service -->
  <circle cx="415" cy="224" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="415" y="228" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">9</text>
  <!-- Step 10: Inbox Service -> Redis / PostgreSQL -->
  <circle cx="752" cy="167" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="752" y="171" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">10</text>

  <!-- ======= LEGEND ======= -->
  <g transform="translate(840,480)">
    <rect x="0" y="0" width="220" height="140" rx="10" fill="#f1f5f9" stroke="#30363d" stroke-width="1"/>
    <text x="15" y="22" fill="#fff" font-size="11" font-weight="700">LEGEND</text>
    <!-- Sync line -->
    <line x1="15" y1="40" x2="55" y2="40" stroke="#9ca3af" stroke-width="1.5" marker-end="url(#arrowSync)"/>
    <text x="65" y="44" fill="#9ca3af" font-size="10">Synchronous call</text>
    <!-- Async line -->
    <line x1="15" y1="60" x2="55" y2="60" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="6,3" marker-end="url(#arrowAsync)"/>
    <text x="65" y="64" fill="#9ca3af" font-size="10">Async / Event-driven</text>
    <!-- Bidirectional -->
    <line x1="15" y1="80" x2="55" y2="80" stroke="#facc15" stroke-width="2" marker-end="url(#arrowBi)" marker-start="url(#arrowBi)"/>
    <text x="65" y="84" fill="#9ca3af" font-size="10">Bidirectional (WS)</text>
    <!-- DB -->
    <ellipse cx="25" cy="100" rx="10" ry="5" fill="#428BF9"/>
    <text x="65" y="104" fill="#9ca3af" font-size="10">Database (PostgreSQL)</text>
    <!-- Redis -->
    <polygon points="25,115 35,122 25,129 15,122" fill="#ef4444" opacity="0.7"/>
    <text x="65" y="126" fill="#9ca3af" font-size="10">Cache (Redis)</text>
  </g>
</svg>
  </div>

  <!-- ===== REQUEST FLOW REFERENCE ===== -->
  <h3>Request Flow Reference</h3>
  <div class="table-wrap">
    <table>
      <thead>
        <tr>
          <th style="width:5%;">Step</th>
          <th style="width:22%;">From &rarr; To</th>
          <th style="width:13%;">Protocol</th>
          <th style="width:60%;">What Happens</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>1</strong></td>
          <td><strong>Client &rarr; WebSocket Server</strong></td>
          <td>WSS</td>
          <td>Client establishes a persistent WebSocket connection for real-time message delivery and typing indicators</td>
        </tr>
        <tr>
          <td><strong>2</strong></td>
          <td><strong>Client &rarr; API Gateway</strong></td>
          <td>HTTPS</td>
          <td>User sends a message via REST/gRPC &mdash; the gateway authenticates the request and applies rate limiting</td>
        </tr>
        <tr>
          <td><strong>3</strong></td>
          <td><strong>API Gateway &rarr; Chat Service</strong></td>
          <td>gRPC</td>
          <td>Chat Service validates the message (permissions, thread membership), generates a <code>message_id</code> (Snowflake), and processes the send</td>
        </tr>
        <tr>
          <td><strong>4</strong></td>
          <td><strong>Chat Service &rarr; PostgreSQL</strong></td>
          <td>TCP</td>
          <td><code>INSERT INTO messages</code> + <code>UPDATE user_threads</code> (last_message, updated_at) in a single transaction</td>
        </tr>
        <tr>
          <td><strong>5</strong></td>
          <td><strong>Chat Service &rarr; Redis</strong></td>
          <td>TCP</td>
          <td>Updates the inbox cache (sorted set by <code>updated_at</code>) and increments unread counts for all thread participants</td>
        </tr>
        <tr>
          <td><strong>6</strong></td>
          <td><strong>Chat Service &rarr; Kafka</strong></td>
          <td>TCP</td>
          <td>Emits a <code>message.sent</code> event to Kafka, keyed by <code>thread_id</code> for partition-level ordering</td>
        </tr>
        <tr>
          <td><strong>7</strong></td>
          <td><strong>Kafka &rarr; WebSocket Server</strong></td>
          <td>Consumer</td>
          <td>WebSocket Server consumes the event, looks up connected recipients via Redis presence, and pushes the message over the open WS connection</td>
        </tr>
        <tr>
          <td><strong>8</strong></td>
          <td><strong>Kafka &rarr; Notification Service</strong></td>
          <td>Consumer</td>
          <td>For participants who are offline (no active WS), the Notification Service sends a push notification or email with the message preview</td>
        </tr>
        <tr>
          <td><strong>9</strong></td>
          <td><strong>Client &rarr; API Gateway &rarr; Inbox Service</strong></td>
          <td>HTTPS</td>
          <td>When the user opens the app, the Inbox Service loads the thread list with last-message previews and unread counts</td>
        </tr>
        <tr>
          <td><strong>10</strong></td>
          <td><strong>Inbox Service &rarr; Redis / PostgreSQL</strong></td>
          <td>TCP</td>
          <td>Tries Redis first for the cached inbox (sorted set). On cache miss, falls back to PostgreSQL <code>user_threads</code> join query and backfills the cache</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- ===== FAILURE PATHS ===== -->
  <h3>Failure Paths</h3>
  <div class="table-wrap">
    <table>
      <thead>
        <tr>
          <th style="width:22%;">Failure</th>
          <th style="width:38%;">Impact</th>
          <th style="width:40%;">Mitigation</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>WebSocket Disconnect</strong></td>
          <td>Client loses the persistent connection &mdash; real-time delivery stops, and the user misses incoming messages until reconnection</td>
          <td>Client-side auto-reconnect with exponential backoff. On reconnect, perform a delta-sync (fetch messages since last known <code>message_id</code>). Fallback to long-polling if WS is blocked by network. Offline messages are always available via Inbox Service.</td>
        </tr>
        <tr>
          <td><strong>PostgreSQL Write Failure</strong></td>
          <td>Message is <strong>lost</strong> &mdash; the send fails and the message is never persisted. Other participants never see it.</td>
          <td>Return a clear error to the sender so they can retry. Use client-side <code>idempotency_key</code> to prevent duplicate inserts on retry. PG replication (primary + sync standby) minimizes single-node failure risk. Circuit-breaker on Chat Service to fail fast during PG outages.</td>
        </tr>
        <tr>
          <td><strong>Redis Cache Miss</strong></td>
          <td>Inbox loads slower because the service must fall back to a PostgreSQL join query instead of a fast cache lookup</td>
          <td>Inbox Service transparently falls back to PG and backfills the Redis cache on read. Pre-warm cache for active users on deploy. Set TTLs with jitter to avoid thundering herd on cache expiry. Monitor cache hit ratio (target &gt; 95%).</td>
        </tr>
        <tr>
          <td><strong>Kafka Consumer Lag</strong></td>
          <td>Delayed delivery to other participants &mdash; online users don&rsquo;t receive messages in real time via WebSocket, and offline users get late push notifications</td>
          <td>Auto-scale consumer group instances based on lag metrics. Partition by <code>thread_id</code> so popular threads don&rsquo;t block others. Alert on consumer lag &gt; 5s. Dead-letter topic for poison messages. Messages are still in PG &mdash; delta-sync on client reconnect ensures eventual consistency.</td>
        </tr>
      </tbody>
    </table>
  </div>

</details>
</section>

<!-- ================================================================== -->
<!-- SECTION 10: TRADE-OFFS TABLE                                       -->
<!-- ================================================================== -->
<section id="tradeoffs">
<details>
  <summary><h2>
    <span class="section-icon" style="background: linear-gradient(135deg, rgba(245,158,11,0.2), rgba(245,158,11,0.06)); color: var(--warning);">&#9878;</span>
    Trade-offs
  </h2></summary>

  <div class="table-wrap">
    <table>
      <thead>
        <tr>
          <th style="width: 18%;">Decision</th>
          <th style="width: 22%;">Option A</th>
          <th style="width: 22%;">Option B</th>
          <th style="width: 38%;">Recommendation</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Client Sync</strong></td>
          <td>
            <span class="badge badge-blue">Pull</span><br>
            Client sends <code>last_updated_at</code>, server queries user_threads index for changes.
            <br><em>+ Fast writes</em>
            <br><em>- Expensive reads for heavy users</em>
          </td>
          <td>
            <span class="badge badge-green">Push (Fan-out)</span><br>
            Server writes to <code>user_messages</code> fan-out table. Client sends <code>max_message_id</code>.
            <br><em>+ Cheap reads, no clock skew</em>
            <br><em>- 50x write amplification</em>
          </td>
          <td>
            <strong>Start with Pull.</strong> At Airbnb's scale (~58 msg/sec), pull is sufficient. The user_threads index handles the sync query efficiently. Reserve push for per-device tracking if needed later. The write amplification of push (up to 250M fan-out rows/day) is not justified at this scale.
          </td>
        </tr>
        <tr>
          <td><strong>Message Store</strong></td>
          <td>
            <span class="badge badge-blue">MySQL / PostgreSQL</span><br>
            ACID transactions, strong consistency, mature tooling, rich query support.
            <br><em>+ Joins, indexes, transactions</em>
            <br><em>- Horizontal scaling requires sharding</em>
          </td>
          <td>
            <span class="badge badge-green">Cassandra</span><br>
            Native horizontal scaling, tunable consistency, great for time-series append.
            <br><em>+ Linear scalability</em>
            <br><em>- No joins, limited queries, eventual consistency</em>
          </td>
          <td>
            <strong>MySQL/PostgreSQL with application-level sharding.</strong> At 58 msg/sec, a single sharded MySQL cluster handles this easily. The inbox query requires joins (user_threads + threads), which Cassandra cannot do. Airbnb is a MySQL shop historically. Cassandra only justified at WhatsApp-scale (100K+ msg/sec).
          </td>
        </tr>
        <tr>
          <td><strong>Real-Time Delivery</strong></td>
          <td>
            <span class="badge badge-blue">WebSocket</span><br>
            Persistent bidirectional connection. Server pushes instantly.
            <br><em>+ Low latency (&lt;200ms)</em>
            <br><em>- Connection state management overhead</em>
          </td>
          <td>
            <span class="badge badge-green">Long Polling</span><br>
            Client holds HTTP connection open, server responds when data is available.
            <br><em>+ Simpler infrastructure</em>
            <br><em>- Higher latency, more HTTP overhead</em>
          </td>
          <td>
            <strong>WebSocket for mobile apps, long polling as fallback for web.</strong> Airbnb's mobile-first audience benefits from persistent WebSocket connections. ~300K concurrent connections is manageable with a dedicated WebSocket gateway cluster. Long polling serves as graceful degradation.
          </td>
        </tr>
        <tr>
          <td><strong>Message Fan-Out</strong></td>
          <td>
            <span class="badge badge-blue">Fan-Out-on-Write</span><br>
            Update all participants' user_threads rows when message is sent.
            <br><em>+ Fast inbox reads</em>
            <br><em>- Write amplification (up to 50 rows per msg)</em>
          </td>
          <td>
            <span class="badge badge-green">Fan-Out-on-Read</span><br>
            Only write message to messages table. Compute inbox by joining at read time.
            <br><em>+ Minimal writes</em>
            <br><em>- Slow inbox query (expensive join)</em>
          </td>
          <td>
            <strong>Fan-out-on-write for user_threads.</strong> The inbox query is latency-sensitive (&lt;100ms SLA). With max 50 participants per thread, the write amplification is bounded. The 50 user_threads updates per message is acceptable at 58 msg/sec (~2,900 row updates/sec). This is a standard pattern used by Slack, Discord, and Facebook Messenger.
          </td>
        </tr>
        <tr>
          <td><strong>Participant Dedup</strong></td>
          <td>
            <span class="badge badge-blue">Hash Lookup</span><br>
            SHA-256 of sorted participant IDs. O(1) lookup.
            <br><em>+ Extremely fast</em>
            <br><em>- Must update hash if participants change</em>
          </td>
          <td>
            <span class="badge badge-green">Set Intersection Query</span><br>
            GROUP BY + HAVING on user_threads.
            <br><em>+ No additional table</em>
            <br><em>- Full table scan, O(N)</em>
          </td>
          <td>
            <strong>Hash lookup.</strong> The cost of maintaining a participant_hash is trivial (one row update on rare participant changes). The alternative set intersection query is O(N) and unacceptable at scale. This is the single most impactful optimization in the design.
          </td>
        </tr>
        <tr>
          <td><strong>Thread Flags</strong></td>
          <td>
            <span class="badge badge-blue">Bitmask Integer</span><br>
            Single INT column with bitwise ops.
            <br><em>+ Compact, atomic, extensible</em>
            <br><em>- Not human-readable in DB</em>
          </td>
          <td>
            <span class="badge badge-green">JSON Column</span><br>
            <code>{"unread": true, "starred": false}</code>
            <br><em>+ Human-readable, flexible schema</em>
            <br><em>- Larger storage, slower queries</em>
          </td>
          <td>
            <strong>Bitmask for hot-path flags, JSON for metadata.</strong> Use bitmask for the 6 common flags (unread, starred, archived, action_required, expired, muted) since these are queried and filtered frequently. Use JSON metadata_context on threads for extensible, rarely-queried properties.
          </td>
        </tr>
      </tbody>
    </table>
  </div>

  <h3>Trade-Off Deep Dive: SQL vs NoSQL for Message Store</h3>
  <p>The most common follow-up: <strong>"Why not use a NoSQL database?"</strong> Here are the realistic options and why SQL wins at Airbnb's scale.</p>

  <div class="card-grid">

    <!-- Option A: PostgreSQL/MySQL (Chosen) -->
    <div class="card" style="border-top: 3px solid var(--secondary); position: relative;">
      <div style="position: absolute; top: 12px; right: 16px;">
        <span style="display:inline-block; padding:3px 10px; border-radius:12px; font-size:0.7em; font-weight:600; background:#10b981; color:#fff;">&#10003; CHOSEN</span>
      </div>
      <h4 style="color: var(--secondary);">A. PostgreSQL / MySQL</h4>
      <p><strong>Why chosen:</strong></p>
      <ul>
        <li><strong>Inbox query needs JOINs</strong> &mdash; <code>user_threads</code> JOIN <code>threads</code> to get the top-20 threads with metadata. NoSQL can't do this without denormalization or scatter-gather.</li>
        <li><strong>ACID transactions</strong> &mdash; the send-message write path (insert message + update N user_threads rows + set UNREAD flags) must be atomic. NoSQL offers limited multi-row transaction support.</li>
        <li><strong>Scale is modest</strong> &mdash; at 58 msg/sec write and 12 inbox QPS, a single sharded MySQL/PG cluster handles this easily. No need for distributed NoSQL overhead.</li>
        <li><strong>Composite indexes</strong> &mdash; <code>(user_id, last_message_at DESC)</code> and <code>(thread_id, created_at DESC)</code> give O(log N + M) access for both inbox and message pagination.</li>
        <li><strong>Airbnb is a MySQL shop</strong> &mdash; proven operational expertise, mature tooling (Vitess for sharding, ProxySQL for routing).</li>
      </ul>
      <p style="margin-top: 10px;"><strong>Trade-off:</strong> Horizontal scaling requires application-level sharding. The <code>user_threads</code> table has a cross-shard dilemma (shard by user_id for reads vs thread_id for writes).</p>
    </div>

    <!-- Option B: Cassandra -->
    <div class="card" style="border-top: 3px solid var(--purple);">
      <h4 style="color: var(--purple);">B. Cassandra</h4>
      <p><strong>Why not:</strong></p>
      <ul>
        <li><strong>No JOINs</strong> &mdash; the inbox query (user_threads + threads + last message) requires multiple round-trips or heavy denormalization, which increases write amplification further.</li>
        <li><strong>Limited transaction support</strong> &mdash; lightweight transactions (LWT) are expensive and don't scale to multi-row atomicity needed for fan-out writes.</li>
        <li><strong>Overkill at 58 msg/sec</strong> &mdash; Cassandra's write-optimized architecture shines at 100K+ writes/sec (WhatsApp, Discord). At Airbnb's scale, it adds operational complexity without benefit.</li>
      </ul>
      <p style="margin-top: 10px;"><strong>When it would win:</strong> If message volume were 100K+ msg/sec and the inbox query could be fully denormalized into a single partition (e.g., a dedicated <code>inbox_by_user</code> table maintained by fan-out-on-write).</p>
    </div>

    <!-- Option C: MongoDB -->
    <div class="card" style="border-top: 3px solid var(--accent);">
      <h4 style="color: var(--accent);">C. MongoDB</h4>
      <p><strong>Why not:</strong></p>
      <ul>
        <li><strong>Document model mismatch</strong> &mdash; threads, messages, and per-user state are inherently relational (many-to-many via user_threads). Embedding messages inside thread documents creates unbounded document growth.</li>
        <li><strong>No multi-document transactions (pre-4.0)</strong> &mdash; the fan-out write path updates documents across multiple collections. Multi-doc transactions in MongoDB add latency and reduce throughput.</li>
        <li><strong>Inbox query requires $lookup</strong> (equivalent to JOIN) &mdash; not significantly faster than SQL JOIN and harder to optimize with indexes.</li>
      </ul>
      <p style="margin-top: 10px;"><strong>When it would win:</strong> If the data model were document-centric (e.g., self-contained threads with embedded messages and fixed participants), and the team had strong MongoDB expertise.</p>
    </div>

    <!-- Option D: DynamoDB -->
    <div class="card" style="border-top: 3px solid var(--blue);">
      <h4 style="color: var(--blue);">D. DynamoDB</h4>
      <p><strong>Why not:</strong></p>
      <ul>
        <li><strong>Single-table design is complex</strong> &mdash; modeling 6 entities (threads, messages, user_threads, hashes, attachments, users) in one table with GSIs requires deep expertise and makes queries brittle.</li>
        <li><strong>GSI fan-out costs</strong> &mdash; each GSI is essentially a full copy of the data. With 4-5 access patterns, storage costs multiply significantly.</li>
        <li><strong>Hot partition risk</strong> &mdash; popular threads concentrate writes on a single partition key, causing throttling under DynamoDB's partition-level throughput limits.</li>
      </ul>
      <p style="margin-top: 10px;"><strong>When it would win:</strong> If the system were fully serverless, the team needed zero-ops infrastructure, and the access patterns were purely key-value (e.g., message lookup by ID only).</p>
    </div>
  </div>

  <div class="card" style="border-left: 4px solid var(--secondary); margin-top: 16px;">
    <h4 style="color: var(--secondary); margin-top: 0;">Summary: Why SQL?</h4>
    <p>The deciding factors are <strong>(1)</strong> the inbox query requires JOIN semantics, <strong>(2)</strong> the send-message path requires multi-row ACID transactions, and <strong>(3)</strong> Airbnb's scale (58 msg/sec) is well within SQL capacity. NoSQL databases solve problems that don't exist here. Use the right tool: SQL for the relational data model, Redis for caching, Kafka for async event delivery.</p>
  </div>

</details>
</section>

<!-- ================================================================== -->
<!-- SECTION 11: INTERVIEW TIPS                                         -->
<!-- ================================================================== -->
<section id="interview-tips">
<details>
  <summary><h2>
    <span class="section-icon" style="background: linear-gradient(135deg, rgba(255,90,95,0.2), rgba(255,90,95,0.15)); color: var(--primary);">&#127919;</span>
    Interview Tips &amp; Calibration
  </h2></summary>

  <h3>Scoring Rubric</h3>
  <p>Based on the Airbnb interview calibration framework, here is how candidates are evaluated on this question:</p>

  <div class="calibration">
    <div class="calibration-row">
      <div class="calibration-label" style="color: #94a3b8;">Baseline</div>
      <div class="calibration-bar">
        <div class="calibration-fill cal-baseline">Correct data models -- all 6 tables present</div>
      </div>
    </div>
    <div class="calibration-row">
      <div class="calibration-label" style="color: var(--blue);">Good</div>
      <div class="calibration-bar">
        <div class="calibration-fill cal-good">+ Composite indexes on user_threads and messages</div>
      </div>
    </div>
    <div class="calibration-row">
      <div class="calibration-label" style="color: #1e293b;">Yes (Hire)</div>
      <div class="calibration-bar">
        <div class="calibration-fill cal-yes">+ End-to-end lifecycle + client sync strategy (pull/push)</div>
      </div>
    </div>
    <div class="calibration-row">
      <div class="calibration-label" style="color: var(--success);">Strong Yes</div>
      <div class="calibration-bar">
        <div class="calibration-fill cal-strong">+ Scalability-aware sharding + caching + horizontal scaling plan</div>
      </div>
    </div>
  </div>

  <h3>What to Nail in Each Part</h3>
  <div class="card-grid">
    <div class="card" style="border-top: 3px solid var(--primary);">
      <h4 style="color: var(--primary);">Part 1: Data Model (15-20 min)</h4>
      <ol>
        <li>Start by listing ALL tables upfront. Draw the ER diagram.</li>
        <li>Explain why <code>user_threads</code> exists as a junction table (not user1_id/user2_id).</li>
        <li>Explain the <code>participant_hash</code> table and the dedup algorithm.</li>
        <li>Walk through the "send message" write path: what rows get updated?</li>
        <li>Define all indexes and justify each one with the access pattern it serves.</li>
        <li>Explain the inbox query access pattern and its O(log U + M) runtime.</li>
      </ol>
    </div>
    <div class="card" style="border-top: 3px solid var(--secondary);">
      <h4 style="color: #1e293b;">Part 2: Client Sync (10-15 min)</h4>
      <ol>
        <li>Explain the offline sync problem clearly.</li>
        <li>Present Pull mode (timestamp-based) as the default approach.</li>
        <li>Present Push mode (fan-out table) as an alternative.</li>
        <li>Articulate the trade-offs: write amplification vs read cost.</li>
        <li>Add WebSocket layer for real-time, explain it does NOT replace sync.</li>
        <li>Mention multi-device sync challenges.</li>
      </ol>
    </div>
    <div class="card" style="border-top: 3px solid var(--purple);">
      <h4 style="color: var(--purple);">Part 3: Scalability (5-10 min)</h4>
      <ol>
        <li>Identify user_threads as the hardest sharding problem.</li>
        <li>Explain the shard-by-user_id vs shard-by-thread_id dilemma.</li>
        <li>Propose the solution: shard by user_id + cache participants.</li>
        <li>Discuss message archival and time-based partitioning.</li>
        <li>Mention caching layer (Redis) for inbox and participant lookups.</li>
        <li>Show you understand the numbers: 58 msg/sec does not need Cassandra.</li>
      </ol>
    </div>
  </div>

  <h3>Common Pitfalls</h3>
  <div class="card" style="border-left: 4px solid var(--danger);">
    <h4 style="color: var(--danger);">&#10060; Mistakes That Drop You to "No Hire"</h4>
    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th>Pitfall</th>
            <th>Why It's Wrong</th>
            <th>Correct Approach</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Putting <code>user1_id, user2_id</code> on the threads table</td>
            <td>Only supports 2-person chat. Cannot represent groups of 3-50. Cannot efficiently query "all threads for user X."</td>
            <td>Use <code>user_threads</code> junction table with compound PK <code>(thread_id, user_id)</code></td>
          </tr>
          <tr>
            <td>Missing the <code>participant_hash</code> table</td>
            <td>Without it, finding an existing thread for a participant group is O(N) full table scan. This is the biggest optimization in the design.</td>
            <td>Compute SHA-256 of sorted participant IDs. Store in <code>thread_participant_hashes</code> with unique index.</td>
          </tr>
          <tr>
            <td>No offline sync strategy</td>
            <td>The interviewer will specifically ask: "How does the client catch up after being offline?" Saying "just reload everything" fails.</td>
            <td>Present pull-based sync with <code>last_updated_at</code> using the <code>user_threads</code> index, then mention push as alternative.</td>
          </tr>
          <tr>
            <td>Jumping to WebSocket / Kafka before data model</td>
            <td>The interviewer is testing your ability to design storage. Infrastructure hand-waving without tables and indexes is a red flag.</td>
            <td>Spend 60% of time on data model + indexes. Add infrastructure as the last layer.</td>
          </tr>
          <tr>
            <td>Using NoSQL (Cassandra/MongoDB) without justification</td>
            <td>At 58 msg/sec, a single MySQL instance handles this. Cassandra adds complexity without benefit. The inbox query needs joins.</td>
            <td>Default to MySQL/PostgreSQL. Only mention Cassandra for write-heavy scenarios (100K+ msg/sec) where joins are unnecessary.</td>
          </tr>
          <tr>
            <td>No indexes defined</td>
            <td>"Just query the database" without explaining which indexes exist and how queries use them shows lack of depth.</td>
            <td>For every query you write, name the index it uses and state the runtime complexity.</td>
          </tr>
          <tr>
            <td>Forgetting idempotency for message sends</td>
            <td>Mobile networks are unreliable. Users will retry sends. Without <code>client_uuid</code>, you get duplicate messages.</td>
            <td>Add <code>client_uuid</code> UNIQUE column on messages. <code>INSERT ... ON CONFLICT DO NOTHING.</code></td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <h3>End-to-End Message Lifecycle</h3>
  <p>Walk the interviewer through a complete lifecycle to demonstrate depth:</p>

  <div class="flow-steps">
    <div class="flow-step" style="border-color: var(--blue); color: var(--blue);">
      <span class="step-label">Step 1</span>
      Guest opens chat
    </div>
    <div class="flow-arrow">&#8594;</div>
    <div class="flow-step" style="border-color: #ffffff; color: var(--secondary);">
      <span class="step-label">Step 2</span>
      Hash participants
    </div>
    <div class="flow-arrow">&#8594;</div>
    <div class="flow-step" style="border-color: var(--purple); color: var(--purple);">
      <span class="step-label">Step 3</span>
      Find or create thread
    </div>
    <div class="flow-arrow">&#8594;</div>
    <div class="flow-step" style="border-color: var(--accent); color: var(--accent);">
      <span class="step-label">Step 4</span>
      Insert message
    </div>
    <div class="flow-arrow">&#8594;</div>
    <div class="flow-step" style="border-color: var(--warning); color: var(--warning);">
      <span class="step-label">Step 5</span>
      Fan-out user_threads
    </div>
    <div class="flow-arrow">&#8594;</div>
    <div class="flow-step" style="border-color: var(--success); color: var(--success);">
      <span class="step-label">Step 6</span>
      WebSocket push / notify
    </div>
  </div>

  <div class="card">
    <h4>Detailed Lifecycle Walkthrough</h4>
    <ol>
      <li><strong>Guest opens chat UI:</strong> Client collects participant list [guest_id, host_id, cohost_id].</li>
      <li><strong>Compute participant hash:</strong> <code>SHA256(sort([101, 202, 303]).join(","))</code> = <code>"a3f2..."</code></li>
      <li><strong>Find or create thread:</strong> Query <code>thread_participant_hashes WHERE participant_hash = 'a3f2...'</code>. If found, return thread_id. If not, create new thread + insert user_threads rows + insert participant hash.</li>
      <li><strong>Insert message:</strong> <code>INSERT INTO messages</code> with <code>client_uuid</code> for idempotency. Update <code>threads.last_modified_at</code>.</li>
      <li><strong>Fan-out user_threads:</strong> UPDATE all <code>user_threads</code> rows for thread participants. Set <code>last_message_at = NOW()</code>, set UNREAD flag for non-senders. This updates the inbox ordering for all participants.</li>
      <li><strong>Real-time push:</strong> Publish event to message bus. WebSocket gateway delivers to online participants. Push notification service sends APNs/FCM to offline participants.</li>
      <li><strong>Cache update:</strong> Write-through update of <code>inbox:{user_id}</code> sorted set in Redis for each participant. Increment <code>unread:{user_id}</code> counter for non-senders.</li>
      <li><strong>Recipient opens inbox:</strong> Query hits Redis cache first. If miss, falls through to <code>user_threads</code> index. Returns top 20 threads with last message preview.</li>
      <li><strong>Recipient opens thread:</strong> Query <code>messages WHERE thread_id = X ORDER BY created_at DESC LIMIT 50</code>. Mark thread as read: clear UNREAD flag, update <code>last_read_message_id</code>.</li>
    </ol>
  </div>

  <h3>Time Allocation Guide</h3>
  <div class="table-wrap">
    <table>
      <thead>
        <tr>
          <th>Phase</th>
          <th>Time</th>
          <th>Focus</th>
          <th>Deliverable</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Clarification</td>
          <td>3-5 min</td>
          <td>Scope: group vs 1:1, scale, persistence, real-time</td>
          <td>Agreed requirements list</td>
        </tr>
        <tr>
          <td>Data Model</td>
          <td>15-20 min</td>
          <td>All 6 tables, indexes, sample queries, runtime analysis</td>
          <td>ER diagram + SQL + complexity</td>
        </tr>
        <tr>
          <td>API Design</td>
          <td>5 min</td>
          <td>REST endpoints with request/response bodies</td>
          <td>5 endpoints defined</td>
        </tr>
        <tr>
          <td>Client Sync</td>
          <td>10-15 min</td>
          <td>Pull vs Push, trade-offs, WebSocket layer</td>
          <td>Sequence diagrams for both</td>
        </tr>
        <tr>
          <td>Scalability</td>
          <td>5-10 min</td>
          <td>Sharding, caching, archival</td>
          <td>Architecture diagram</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="tip-box tip">
    <strong>Final Interview Tip:</strong>
    The strongest signal you can give is demonstrating that you understand WHY each table exists, not just WHAT it contains. Every table should be justified by a specific query or access pattern. If you can walk the interviewer through the full send-message lifecycle -- from API call to database writes to WebSocket delivery to inbox cache update -- and explain the runtime at each step, you will get a Strong Yes.
  </div>
</details>
</section>

</div>

<!-- ========== FOOTER ========== -->
<div class="footer">
  <p><a href="index.html">&#8592; Back to All Topics</a> &nbsp;|&nbsp; Topic 04 of 18 &nbsp;|&nbsp; Airbnb Group Chat Messaging System</p>
  <p style="margin-top: 8px;">Principal Engineer Level System Design Reference</p>
</div>

<script>
document.querySelectorAll('.toc a[href^="#"], nav a[href^="#"]').forEach(function(link) {
  link.addEventListener('click', function() {
    var id = this.getAttribute('href').slice(1);
    var section = document.getElementById(id);
    if (section) { var d = section.querySelector('details'); if (d) d.open = true; }
  });
});
</script>

<script>
(function(){
  document.querySelectorAll(".diagram-box").forEach(function(box){
    var svg=box.querySelector("svg");
    if(!svg) return;
    var zoom=1, minZ=0.5, maxZ=3;
    var ctrl=document.createElement("div");
    ctrl.className="diagram-zoom-controls";
    ctrl.innerHTML='<button class="zoom-out" title="Zoom Out">âˆ’</button><span class="zoom-level">100%</span><button class="zoom-in" title="Zoom In">+</button><button class="zoom-reset" title="Reset">â†º</button><button class="zoom-fs" title="Fullscreen">â¤¢</button>';
    box.insertBefore(ctrl,box.firstChild);
    var lvl=ctrl.querySelector(".zoom-level");
    function apply(){svg.style.transform="scale("+zoom+")";lvl.textContent=Math.round(zoom*100)+"%";}
    ctrl.querySelector(".zoom-in").onclick=function(){zoom=Math.min(maxZ,zoom+0.25);apply();};
    ctrl.querySelector(".zoom-out").onclick=function(){zoom=Math.max(minZ,zoom-0.25);apply();};
    ctrl.querySelector(".zoom-reset").onclick=function(){zoom=1;apply();};
    ctrl.querySelector(".zoom-fs").onclick=function(){
      box.classList.toggle("fullscreen");
      if(box.classList.contains("fullscreen")){this.textContent="âœ•";zoom=1.2;}else{this.textContent="â¤¢";zoom=1;}
      apply();
    };
    box.addEventListener("wheel",function(e){
      if(e.ctrlKey){e.preventDefault();zoom=e.deltaY<0?Math.min(maxZ,zoom+0.1):Math.max(minZ,zoom-0.1);apply();}
    },{passive:false});
  });
})();
</script>
</body>
</html>
