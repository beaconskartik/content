<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>National Weather Service API - Airbnb System Design Interview</title>
<style>
  :root {
    --primary: #FF5A5F;
    --primary-dark: #E04850;
    --secondary: #00A699;
    --accent: #FC642D;
    --purple: #7B2FF7;
    --blue: #428BF9;
    --dark: #ffffff;
    --darker: #f1f5f9;
    --card-bg: #ffffff;
    --card-border: #e2e8f0;
    --text: #1e293b;
    --text-muted: #4b5563;
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--dark);
    color: var(--text);
    line-height: 1.7;
    scroll-behavior: smooth;
  }

  /* HERO */
  .hero {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #6B73FF 100%);
    padding: 60px 40px;
    text-align: center;
    border-bottom: 3px solid var(--primary);
    position: relative;
    overflow: hidden;
  }
  .hero::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle at 30% 50%, rgba(255,90,95,0.15) 0%, transparent 50%),
                radial-gradient(circle at 70% 50%, rgba(0,166,153,0.15) 0%, transparent 50%);
    animation: pulse 8s ease-in-out infinite;
  }
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  .hero h1 {
    font-size: 2.8em;
    background: linear-gradient(135deg, #ffffff, #e0e7ff, #ffffff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    position: relative;
    margin-bottom: 10px;
  }
  .hero .subtitle {
    font-size: 1.2em;
    color: rgba(255,255,255,0.9);
    position: relative;
    margin-bottom: 8px;
  }
  .hero .topic-number-hero {
    position: relative;
    font-size: 0.95em;
    color: var(--text-muted);
    margin-bottom: 15px;
  }
  .hero .back-link {
    position: relative;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    color: #ffffff;
    text-decoration: none;
    font-size: 0.95em;
    font-weight: 600;
    padding: 10px 24px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.4);
    background: rgba(255,255,255,0.15);
    transition: all 0.3s;
    margin-bottom: 20px;
  }
  .hero .back-link:hover {
    background: rgba(255,255,255,0.25);
    border-color: #e5e7eb;
    transform: translateX(-3px);
  }
  .hero .stats-row {
    position: relative;
    display: flex;
    justify-content: center;
    gap: 30px;
    margin-top: 20px;
    flex-wrap: wrap;
  }
  .hero .stat-item { text-align: center; }
  .hero .stat-value {
    font-size: 2em;
    font-weight: 800;
    color: var(--primary);
  }
  .hero .stat-label {
    font-size: 0.8em;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1.5px;
  }

  /* BADGES */
  .badge {
    display: inline-block;
    padding: 4px 14px;
    border-radius: 20px;
    font-size: 0.8em;
    font-weight: 600;
    margin: 3px 2px;
  }
  .badge-red { background: rgba(255,255,255,0.15); color: #ffffff; border: 1px solid rgba(255,255,255,0.3); }
  .badge-green { background: rgba(0,166,153,0.2); color: #ffffff; border: 1px solid var(--secondary); }
  .badge-blue { background: rgba(255,255,255,0.15); color: #ffffff; border: 1px solid rgba(255,255,255,0.3); }
  .badge-purple { background: rgba(255,255,255,0.15); color: #ffffff; border: 1px solid rgba(255,255,255,0.3); }
  .badge-orange { background: rgba(255,255,255,0.15); color: #ffffff; border: 1px solid rgba(255,255,255,0.3); }
  .badge-yellow { background: rgba(245,158,11,0.2); color: var(--warning); border: 1px solid var(--warning); }

  /* NAV */
  .toc {
    background: #f8fafc;
    padding: 30px 40px;
    border-bottom: 1px solid var(--card-border);
    position: sticky;
    top: 0;
    z-index: 100;
    backdrop-filter: blur(12px);
  }
  .toc h2 { color: var(--secondary); margin-bottom: 15px; font-size: 1.1em; text-transform: uppercase; letter-spacing: 2px; }
  .toc-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }
  .toc a {
    color: var(--text-muted);
    text-decoration: none;
    padding: 6px 16px;
    border-radius: 8px;
    background: var(--card-bg);
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    font-size: 0.85em;
    transition: all 0.3s;
  }
  .toc a:hover {
    color: var(--primary);
    border-color: var(--primary);
    background: rgba(255,90,95,0.1);
  }

  /* SECTIONS */
  .container { max-width: 1300px; margin: 0 auto; padding: 0 30px; }
  section { padding: 50px 0; border-bottom: 1px solid var(--card-border); }
  section:last-of-type { border-bottom: none; }
  section h2 {
    font-size: 2em;
    margin-bottom: 25px;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  section h2 .icon {
    width: 40px;
    height: 40px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2em;
  }
  section h3 {
    font-size: 1.3em;
    color: #ffffff;
    margin: 25px 0 12px;
    padding-left: 12px;
    border-left: 3px solid var(--secondary);
  }
  section h4 {
    font-size: 1.1em;
    color: var(--blue);
    margin: 18px 0 8px;
  }
  p { margin: 10px 0; }

  /* CARDS */
  .card {
    background: var(--card-bg);
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 12px;
    padding: 24px;
    margin: 15px 0;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
  }
  .card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin: 20px 0;
  }
  .card-header {
    font-size: 1.1em;
    font-weight: 700;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* DIAGRAM BOXES */
  .diagram-box {
    background: linear-gradient(135deg, var(--card-bg), var(--darker));
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 16px;
    padding: 30px;
    margin: 25px 0;
    overflow-x: auto;
  }

  /* TABLES */
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    font-size: 0.92em;
  }
  th {
    background: linear-gradient(135deg, rgba(255,90,95,0.15), rgba(0,166,153,0.15));
    color: var(--text);
    padding: 12px 16px;
    text-align: left;
    font-weight: 600;
    border-bottom: 2px solid var(--primary);
  }
  td {
    padding: 10px 16px;
    border-bottom: 1px solid var(--card-border);
  }
  tr:hover td { background: rgba(255,255,255,0.03); }

  /* CODE */
  pre {
    background: #f6f8fa;
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 10px;
    padding: 20px;
    overflow-x: auto;
    font-family: 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
    font-size: 0.88em;
    line-height: 1.6;
    margin: 15px 0;
    color: #24292f;
  }
  code {
    font-family: 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
    font-size: 0.9em;
  }
  .keyword { color: #cf222e; }
  .string { color: #0a3069; }
  .comment { color: #6e7781; }
  .type { color: #8250df; }
  .func { color: #0550ae; }
  .number { color: #f0883e; }
  .inline-code {
    background: rgba(255,255,255,0.08);
    padding: 2px 8px;
    border-radius: 5px;
    font-size: 0.88em;
    color: var(--accent);
    font-family: 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
  }

  /* TIPS */
  .tip-box {
    border-radius: 12px;
    padding: 20px 24px;
    margin: 20px 0;
    border-left: 4px solid;
  }
  .tip-interview {
    background: rgba(123,47,247,0.1);
    border-color: var(--purple);
  }
  .tip-warning {
    background: rgba(245,158,11,0.1);
    border-color: var(--warning);
  }
  .tip-success {
    background: rgba(16,185,129,0.1);
    border-color: var(--success);
  }
  .tip-danger {
    background: rgba(239,68,68,0.1);
    border-color: var(--danger);
  }
  .tip-info {
    background: rgba(66,139,249,0.08);
    border-color: var(--blue);
  }
  .tip-box .tip-title {
    font-weight: 700;
    margin-bottom: 6px;
    font-size: 0.95em;
  }

  /* FLOW ITEMS */
  .flow-steps {
    display: flex;
    flex-wrap: wrap;
    gap: 0;
    margin: 20px 0;
    align-items: center;
  }
  .flow-step {
    background: var(--card-bg);
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 10px;
    padding: 12px 20px;
    text-align: center;
    font-size: 0.9em;
    min-width: 140px;
  }
  .flow-arrow {
    color: var(--primary);
    font-size: 1.5em;
    padding: 0 5px;
  }

  /* LISTS */
  ul { padding-left: 20px; margin: 8px 0; }
  li { margin: 4px 0; }
  li::marker { color: var(--primary); }

  /* COMPARISON */
  .comparison {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 20px 0;
  }
  .option-a { border-top: 3px solid var(--secondary); }
  .option-b { border-top: 3px solid var(--accent); }
  .option-c { border-top: 3px solid var(--purple); }

  /* METRIC CARDS */
  .metric-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin: 20px 0;
  }
  .metric-card {
    background: var(--card-bg);
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 12px;
    padding: 20px;
    text-align: center;
  }
  .metric-value {
    font-size: 2em;
    font-weight: 800;
    background: linear-gradient(135deg, var(--primary), var(--accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .metric-label {
    color: var(--text-muted);
    font-size: 0.85em;
    margin-top: 4px;
  }

  /* ARCHITECTURE DIAGRAM */
  .arch-diagram {
    background: rgba(0,0,0,0.05);
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 12px;
    padding: 20px;
    margin: 20px 0;
    overflow-x: auto;
    text-align: center;
  }
  .arch-diagram svg {
    max-width: 100%;
    height: auto;
  }

  /* SCHEMA BOX */
  .schema-box {
    background: #f6f8fa;
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 12px;
    padding: 24px;
    margin: 15px 0;
    font-family: 'Cascadia Code', 'Fira Code', 'Consolas', monospace;
    font-size: 0.85em;
    line-height: 1.7;
    overflow-x: auto;
  }
  .schema-box .table-name {
    color: var(--accent);
    font-weight: 700;
    font-size: 1.05em;
  }
  .schema-box .col-name { color: #0550ae; }
  .schema-box .col-type { color: #8250df; }
  .schema-box .col-constraint { color: #cf222e; }
  .schema-box .col-comment { color: #6e7781; }

  /* NUMBERED STEPS */
  .step-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 16px;
    margin: 20px 0;
  }
  .step-item {
    background: var(--card-bg);
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 12px;
    padding: 20px 24px;
    display: flex;
    gap: 16px;
    align-items: flex-start;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .step-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
  }
  .step-num {
    width: 36px;
    height: 36px;
    min-width: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 800;
    font-size: 0.9em;
    background: linear-gradient(135deg, var(--primary), var(--accent));
    color: white;
  }
  .step-content { flex: 1; }
  .step-content strong { color: var(--text); }

  /* TAG PILLS */
  .tag-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin: 10px 0;
  }
  .tag {
    padding: 4px 12px;
    border-radius: 6px;
    font-size: 0.78em;
    font-weight: 600;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
  }

  /* TRADE-OFF TABLE */
  .tradeoff-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 20px 0;
  }
  .tradeoff-card {
    background: var(--card-bg);
    border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    border-radius: 12px;
    padding: 24px;
    transition: transform 0.2s;
  }
  .tradeoff-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
  }
  .tradeoff-card .tradeoff-title {
    font-weight: 700;
    font-size: 1.05em;
    margin-bottom: 8px;
    color: var(--text);
  }
  .tradeoff-card .pro { color: var(--success); }
  .tradeoff-card .con { color: var(--danger); }
  .tradeoff-card .verdict { color: var(--warning); font-weight: 600; margin-top: 8px; }

  /* FOOTER */
  footer {
    background: #f8fafc;
    padding: 30px 40px;
    text-align: center;
    color: var(--text-muted);
    font-size: 0.85em;
    border-top: 1px solid #e5e7eb;
  }
  footer a { color: var(--secondary); text-decoration: none; }
  footer a:hover { color: var(--primary); }

  /* RESPONSIVE */
  @media (max-width: 768px) {
    .hero { padding: 50px 20px 40px; }
    .hero h1 { font-size: 1.8em; }
    .hero .subtitle { font-size: 1em; }
    .hero .stats-row { gap: 20px; }
    .hero .stat-value { font-size: 1.5em; }
    .toc { padding: 15px 20px; }
    .container { padding: 0 15px; }
    section { padding: 30px 0; }
    .comparison { grid-template-columns: 1fr; }
    .tradeoff-grid { grid-template-columns: 1fr; }
    .card-grid { grid-template-columns: 1fr; }
    section h2 { font-size: 1.5em; }
    .arch-diagram { padding: 12px; }
    table { font-size: 0.82em; display: block; overflow-x: auto; -webkit-overflow-scrolling: touch; }
    .diagram-box { overflow-x: auto; -webkit-overflow-scrolling: touch; }
    .diagram-box svg { min-width: 600px; }
  }
  @media (max-width: 480px) {
    .hero h1 { font-size: 1.5em; }
    .flow-steps { flex-direction: column; }
    .flow-arrow { transform: rotate(90deg); }
  }
  @media (max-width: 360px) {
    .hero h1 { font-size: 1.15em; }
    .hero .stat-value { font-size: 1em; }
    .container { padding: 10px 8px; }
  }
  /* === DIAGRAM ZOOM CONTROLS === */
  .diagram-box { position: relative; }
  .diagram-zoom-controls {
    position: absolute; top: 12px; right: 12px; z-index: 10;
    display: flex; gap: 4px; opacity: 0.5; transition: opacity 0.3s;
  }
  .diagram-box:hover .diagram-zoom-controls { opacity: 1; }
  .diagram-zoom-controls button {
    width: 32px; height: 32px; border-radius: 8px; border: 1px solid #e5e7eb;
    background: #ffffff; color: #1e293b; cursor: pointer; font-size: 16px;
    display: flex; align-items: center; justify-content: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: all 0.2s;
    font-family: system-ui; line-height: 1; padding: 0;
  }
  .diagram-zoom-controls button:hover { background: #f1f5f9; border-color: var(--blue); color: var(--blue); }
  .diagram-zoom-controls button:active { transform: scale(0.95); }
  .diagram-zoom-controls .zoom-level {
    font-size: 11px; color: #64748b; display: flex; align-items: center;
    padding: 0 6px; font-weight: 600; min-width: 40px; justify-content: center;
  }
  .diagram-box svg { transition: transform 0.3s ease; transform-origin: center center; }
  .diagram-box.fullscreen {
    position: fixed !important; top: 0; left: 0; width: 100vw; height: 100vh;
    z-index: 9999; background: #ffffff; border-radius: 0; padding: 20px;
    display: flex; align-items: center; justify-content: center;
    overflow: auto;
  }
  .diagram-box.fullscreen .diagram-zoom-controls { opacity: 1; top: 20px; right: 20px; }
</style>
</head>
<body>

<!-- ==================== HERO ==================== -->
<div class="hero">
  <a href="index.html" class="back-link">&#8592; Back to All Topics</a>
  <h1>National Weather Service API</h1>
  <p class="subtitle">Design an API to serve weather data from 5,000+ stations to millions of clients</p>
  <p class="topic-number-hero">Topic 13 of 18 &mdash; External APIs &amp; Data Ingestion</p>
  <div style="margin-top:12px; position:relative;">
    <span class="badge badge-red">System Design</span>
    <span class="badge badge-green">API Design</span>
    <span class="badge badge-blue">Data Ingestion</span>
    <span class="badge badge-purple">Geo Mapping</span>
    <span class="badge badge-orange">Caching</span>
    <span class="badge badge-yellow">Rate Limiting</span>
  </div>
  <div class="stats-row">
    <div class="stat-item">
      <div class="stat-value">~5K</div>
      <div class="stat-label">Weather Stations</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">~55M</div>
      <div class="stat-label">Historical Rows</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">~42K</div>
      <div class="stat-label">US Zip Codes</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">30yr</div>
      <div class="stat-label">Data History</div>
    </div>
  </div>
</div>

<!-- ==================== NAV ==================== -->
<nav class="toc">
  <h2>Navigation</h2>
  <div class="toc-grid">
    <a href="#overview">Overview</a>
    <a href="#requirements">Requirements</a>
    <a href="#ingestion">Data Ingestion</a>
    <a href="#geo-mapping">Geo Mapping</a>
    <a href="#data-model">Data Model</a>
    <a href="#api-design">API Design</a>
    <a href="#caching">Caching</a>
    <a href="#edge-cases">Edge Cases</a>
    <a href="#scaling">Scaling</a>
    <a href="#tradeoffs">Trade-offs</a>
    <a href="#extensions">Extensions</a>
    <a href="#interview-tips">Interview Tips</a>
  </div>
</nav>

<div class="container">

<!-- ==================== SECTION 1: OVERVIEW ==================== -->
<section id="overview">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--blue), var(--secondary));">&#9729;</span> System Overview</h2>

  <p>The National Weather Service operates thousands of weather stations across the country. Each station sends a <strong>daily CSV file</strong> containing two datasets: a <strong>10-day forecast</strong> (predicted highs and lows) and the <strong>previous day's actual temperatures</strong>. Our job is to design an HTTP API that makes this data accessible to downstream clients &mdash; weather websites, newspaper weather sections, mobile apps, and other programmatic consumers.</p>

  <div class="tip-box tip-interview">
    <div class="tip-title" style="color:var(--purple);">Interview Context</div>
    <p>This is a classic <strong>Airbnb-style system design</strong> question. It tests data ingestion pipelines, geo-spatial mapping, API design, caching strategy, and how you handle messy real-world data. The scale is moderate (not billions of rows), so the focus shifts to <strong>data quality, correctness, and clean API design</strong> rather than raw throughput.</p>
  </div>

  <div class="card-grid">
    <div class="card" style="border-top: 3px solid var(--blue);">
      <div class="card-header" style="color:var(--blue);">&#127777; Data Per Station (Daily CSV)</div>
      <ul>
        <li><strong>Station metadata:</strong> name, latitude, longitude</li>
        <li><strong>10-day forecast:</strong> date, predicted high, predicted low</li>
        <li><strong>Yesterday's actuals:</strong> date, actual high, actual low</li>
        <li>Each row includes the <code class="inline-code">date_sent</code> so we track <em>which day's prediction</em> it was</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--secondary);">
      <div class="card-header" style="color:var(--secondary);">&#128187; API Consumers</div>
      <ul>
        <li><strong>Weather websites</strong> &mdash; real-time forecast widgets</li>
        <li><strong>Newspaper weather sections</strong> &mdash; daily batch pull</li>
        <li><strong>Mobile apps</strong> &mdash; location-based forecasts</li>
        <li><strong>Data scientists</strong> &mdash; historical trend analysis</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--accent);">
      <div class="card-header" style="color:var(--accent);">&#127919; Core Challenge</div>
      <ul>
        <li>Users query by <strong>zip code</strong> or <strong>city name</strong></li>
        <li>Stations are identified by <strong>lat/lng coordinates</strong></li>
        <li>Must <strong>bridge the gap</strong>: map user locations to nearest stations</li>
        <li>Handle missing, late, or unreliable station data gracefully</li>
      </ul>
    </div>
  </div>

  <h3>Data Volume Estimation</h3>
  <div class="metric-grid">
    <div class="metric-card">
      <div class="metric-value">~5,000</div>
      <div class="metric-label">Weather Stations (US)</div>
    </div>
    <div class="metric-card">
      <div class="metric-value">~55M</div>
      <div class="metric-label">Historical Rows (30yr)</div>
    </div>
    <div class="metric-card">
      <div class="metric-value">~50K</div>
      <div class="metric-label">New Rows / Day</div>
    </div>
    <div class="metric-card">
      <div class="metric-value">~10 GB</div>
      <div class="metric-label">Total DB Size</div>
    </div>
  </div>

  <div class="tip-box tip-success">
    <div class="tip-title" style="color:var(--success);">Key Insight: Small Data, Big Read Scale</div>
    <p>5,000 stations &times; 365 days &times; 30 years = ~55 million rows. This is a <strong>small dataset</strong> that easily fits in a single PostgreSQL instance. The real scaling challenge is on the <strong>read side</strong> &mdash; millions of API clients hitting the same data. This shifts the architecture toward aggressive caching and CDN strategies rather than database sharding.</p>
  </div>
</section>

<!-- ==================== SECTION 2: REQUIREMENTS ==================== -->
<section id="requirements">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--secondary), var(--blue));">&#128203;</span> Requirements</h2>

  <h3>Functional Requirements</h3>
  <div class="card-grid">
    <div class="card" style="border-top: 3px solid var(--primary);">
      <div class="card-header" style="color:var(--primary);">FR1: Location-Based Query</div>
      <ul>
        <li>Query by <strong>zip code</strong> (e.g., 94110) or <strong>city name</strong> (e.g., "San Francisco")</li>
        <li>System maps location to nearest weather station(s)</li>
        <li>Return weather data from the most relevant station</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--secondary);">
      <div class="card-header" style="color:var(--secondary);">FR2: Date Range Query</div>
      <ul>
        <li>Specify <strong>start_date</strong> and <strong>end_date</strong> for weather data</li>
        <li>Return daily high and low temperatures for each day</li>
        <li>Support both <strong>historical</strong> (past) and <strong>forecast</strong> (future) queries</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--blue);">
      <div class="card-header" style="color:var(--blue);">FR3: Data Type Selection</div>
      <ul>
        <li>Request <strong>actual</strong> (observed) or <strong>predicted</strong> (forecast) data</li>
        <li>Predicted data includes which day the prediction was made</li>
        <li>Gracefully indicate when requested data type is unavailable</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--purple);">
      <div class="card-header" style="color:var(--purple);">FR4: Missing Data Handling</div>
      <ul>
        <li>If nearest station has no data, <strong>fall back</strong> to 2nd or 3rd nearest</li>
        <li>Clearly indicate in response which station provided the data</li>
        <li>Mark days with no available data rather than silently omitting</li>
      </ul>
    </div>
  </div>

  <h3>Non-Functional Requirements</h3>
  <div class="card-grid">
    <div class="card" style="border-top: 3px solid var(--warning);">
      <div class="card-header" style="color:var(--warning);">NFR1: Low Latency</div>
      <ul>
        <li>p50 response time <strong>&lt; 100ms</strong> for cached queries</li>
        <li>p99 response time <strong>&lt; 500ms</strong> for cold queries</li>
        <li>Forecast data (hot path) should be served from cache</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--danger);">
      <div class="card-header" style="color:var(--danger);">NFR2: Rate Limiting</div>
      <ul>
        <li>Per API-key rate limits to prevent abuse</li>
        <li>Tiered pricing: free tier (1K/day), pro (100K/day), enterprise (unlimited)</li>
        <li>Return <code class="inline-code">429 Too Many Requests</code> with retry-after header</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--success);">
      <div class="card-header" style="color:var(--success);">NFR3: Authentication</div>
      <ul>
        <li>API key-based authentication for all requests</li>
        <li>HMAC request signing for tamper-proof requests</li>
        <li>Key rotation support without service interruption</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--blue);">
      <div class="card-header" style="color:var(--blue);">NFR4: Caching</div>
      <ul>
        <li>Multi-layer caching: CDN, application-level (Redis), HTTP cache headers</li>
        <li>Different TTLs for forecast vs. historical data</li>
        <li>Cache invalidation when new CSV data arrives daily</li>
      </ul>
    </div>
  </div>
</section>

<!-- ==================== SECTION 3: DATA INGESTION ==================== -->
<section id="ingestion">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--accent), var(--primary));">&#128229;</span> Data Ingestion Pipeline</h2>

  <p>Every day, each of the ~5,000 weather stations uploads a CSV file containing 10 rows of predicted data (today through 9 days out) and 1 row of actual data (yesterday). The ingestion pipeline must reliably parse, validate, and store this data.</p>

  <h3>Ingestion Flow</h3>
  <div class="flow-steps">
    <div class="flow-step" style="border-color:var(--secondary);">&#128225; Stations<br>Upload CSV</div>
    <div class="flow-arrow">&#8594;</div>
    <div class="flow-step" style="border-color:var(--blue);">&#128193; File Landing<br>Zone (S3)</div>
    <div class="flow-arrow">&#8594;</div>
    <div class="flow-step" style="border-color:var(--purple);">&#9881; Cron Job<br>Parser</div>
    <div class="flow-arrow">&#8594;</div>
    <div class="flow-step" style="border-color:var(--warning);">&#9989; Validation<br>Layer</div>
    <div class="flow-arrow">&#8594;</div>
    <div class="flow-step" style="border-color:var(--primary);">&#128451; PostgreSQL<br>Database</div>
    <div class="flow-arrow">&#8594;</div>
    <div class="flow-step" style="border-color:var(--success);">&#128165; Cache<br>Invalidation</div>
  </div>

  <h3>Sample CSV Format</h3>
  <pre><span class="comment"># Station: STATION_042, Lat: 37.7749, Lng: -122.4194</span>
<span class="comment"># Date Sent: 2025-01-15</span>
<span class="comment"># type, date, high_temp_f, low_temp_f</span>
<span class="keyword">actual</span>,   <span class="string">2025-01-14</span>, <span class="number">58</span>, <span class="number">42</span>
<span class="keyword">predicted</span>,<span class="string">2025-01-15</span>, <span class="number">60</span>, <span class="number">45</span>
<span class="keyword">predicted</span>,<span class="string">2025-01-16</span>, <span class="number">62</span>, <span class="number">44</span>
<span class="keyword">predicted</span>,<span class="string">2025-01-17</span>, <span class="number">59</span>, <span class="number">43</span>
<span class="keyword">predicted</span>,<span class="string">2025-01-18</span>, <span class="number">55</span>, <span class="number">40</span>
<span class="keyword">predicted</span>,<span class="string">2025-01-19</span>, <span class="number">57</span>, <span class="number">41</span>
<span class="keyword">predicted</span>,<span class="string">2025-01-20</span>, <span class="number">61</span>, <span class="number">46</span>
<span class="keyword">predicted</span>,<span class="string">2025-01-21</span>, <span class="number">63</span>, <span class="number">47</span>
<span class="keyword">predicted</span>,<span class="string">2025-01-22</span>, <span class="number">64</span>, <span class="number">48</span>
<span class="keyword">predicted</span>,<span class="string">2025-01-23</span>, <span class="number">60</span>, <span class="number">44</span>
<span class="keyword">predicted</span>,<span class="string">2025-01-24</span>, <span class="number">58</span>, <span class="number">42</span></pre>

  <h3>Ingestion Pipeline Details</h3>
  <div class="step-grid">
    <div class="step-item">
      <div class="step-num">1</div>
      <div class="step-content">
        <strong>File Collection</strong>
        <p>Stations push CSV files to an S3 bucket (or SFTP). Each file is named with a convention: <code class="inline-code">STATION_042_2025-01-15.csv</code>. An S3 event trigger or cron job (running at ~2 AM daily) picks up new files.</p>
      </div>
    </div>
    <div class="step-item">
      <div class="step-num">2</div>
      <div class="step-content">
        <strong>CSV Parsing &amp; Validation</strong>
        <p>Parse each row and validate: temperatures within reasonable bounds (-60&deg;F to 140&deg;F), dates are correct, station ID exists. Reject malformed rows with logging. Track parse success rate per station.</p>
      </div>
    </div>
    <div class="step-item">
      <div class="step-num">3</div>
      <div class="step-content">
        <strong>Deduplication</strong>
        <p>Use <code class="inline-code">UNIQUE</code> constraints on <code class="inline-code">(station_id, date_actual)</code> for actuals and <code class="inline-code">(station_id, date_sent, date_predicted)</code> for predictions. Use <code class="inline-code">INSERT ... ON CONFLICT DO UPDATE</code> to handle re-processing or late corrections.</p>
      </div>
    </div>
    <div class="step-item">
      <div class="step-num">4</div>
      <div class="step-content">
        <strong>Late Arrival Handling</strong>
        <p>Some stations may upload late (network issues, maintenance). The pipeline runs multiple times per day. If a station's file arrives 6 hours late, the next run picks it up. Flag stations that are consistently late for reliability scoring.</p>
      </div>
    </div>
    <div class="step-item">
      <div class="step-num">5</div>
      <div class="step-content">
        <strong>Cache Invalidation</strong>
        <p>After successful ingestion, invalidate affected cache entries. For each station processed, clear Redis keys for all zip codes mapped to that station. Publish a message to a cache-invalidation topic for CDN purge.</p>
      </div>
    </div>
  </div>

  <div class="tip-box tip-warning">
    <div class="tip-title" style="color:var(--warning);">Handling Duplicate Predictions</div>
    <p>Each day, a station sends a new 10-day forecast. That means for any given future date, we receive <strong>multiple predictions from different days</strong>. For example, the forecast for January 20th is predicted on Jan 10, Jan 11, Jan 12, etc. We store <em>all</em> of them (keyed by <code class="inline-code">date_sent + date_predicted</code>) because clients may want to see how forecasts evolve. The API defaults to the <strong>most recent prediction</strong> unless the client requests a specific <code class="inline-code">date_sent</code>.</p>
  </div>

  <h3>Ingestion Pipeline Code</h3>
  <pre><span class="keyword">class</span> <span class="type">WeatherCSVIngester</span>:
    <span class="keyword">def</span> <span class="func">process_daily_files</span>(self):
        <span class="string">"""Cron job: runs every 4 hours to catch late arrivals."""</span>
        files = self.s3.list_unprocessed_files(bucket=<span class="string">"weather-csv-landing"</span>)

        <span class="keyword">for</span> file <span class="keyword">in</span> files:
            <span class="keyword">try</span>:
                station_id, date_sent = self.parse_filename(file.key)
                rows = self.parse_csv(file.body)

                <span class="keyword">for</span> row <span class="keyword">in</span> rows:
                    <span class="keyword">if not</span> self.validate_row(row):
                        self.log_bad_row(station_id, row)
                        <span class="keyword">continue</span>

                    <span class="keyword">if</span> row.type == <span class="string">"actual"</span>:
                        self.upsert_actual(station_id, row)
                    <span class="keyword">elif</span> row.type == <span class="string">"predicted"</span>:
                        self.upsert_predicted(station_id, date_sent, row)

                self.invalidate_cache(station_id)
                self.mark_file_processed(file.key)
                self.update_station_reliability(station_id, date_sent)

            <span class="keyword">except</span> <span class="type">Exception</span> <span class="keyword">as</span> e:
                self.alert_on_failure(file.key, e)

    <span class="keyword">def</span> <span class="func">validate_row</span>(self, row):
        <span class="string">"""Sanity check temperature bounds and date validity."""</span>
        <span class="keyword">return</span> (
            <span class="number">-60</span> &lt;= row.high &lt;= <span class="number">140</span> <span class="keyword">and</span>
            <span class="number">-60</span> &lt;= row.low &lt;= <span class="number">140</span> <span class="keyword">and</span>
            row.low &lt;= row.high <span class="keyword">and</span>
            self.is_valid_date(row.date)
        )</pre>
</section>

<!-- ==================== SECTION 4: GEO MAPPING ==================== -->
<section id="geo-mapping">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--purple), var(--blue));">&#127758;</span> Geo Mapping: Zip Code to Station</h2>

  <p>The central challenge: users query by zip code or city, but weather data is organized by station. We need an efficient way to map any US zip code to the nearest weather station(s).</p>

  <h3>Option A: On-Demand Distance Calculation (Rejected)</h3>
  <div class="card" style="border-top: 3px solid var(--danger);">
    <div class="card-header" style="color:var(--danger);">&#10060; O(N) Per Request &mdash; Too Slow</div>
    <p>For each API request, calculate the distance from the queried zip code's coordinates to every station (~5,000 stations), sort by distance, and pick the nearest.</p>
    <ul>
      <li><strong>Time complexity:</strong> O(N) per request where N = number of stations</li>
      <li><strong>Latency:</strong> 5,000 haversine calculations per request, ~5-10ms of pure compute</li>
      <li><strong>Problem:</strong> Wasteful &mdash; the mapping barely changes (new stations are rare)</li>
      <li><strong>Problem:</strong> Cannot leverage caching effectively since the computation is on the hot path</li>
    </ul>
  </div>

  <h3>Option B: Pre-Computed Mapping Table (Chosen)</h3>
  <div class="card" style="border-top: 3px solid var(--success);">
    <div class="card-header" style="color:var(--success);">&#9989; O(1) Per Request &mdash; Pre-Compute via Cron</div>
    <p>Pre-compute the nearest 3 stations for every US zip code (~42,000 zip codes) using a nightly cron job. Store in a mapping table. API lookups become a simple <code class="inline-code">SELECT</code>.</p>
    <ul>
      <li><strong>Pre-computation:</strong> 42,000 zip codes &times; 5,000 stations = 210M haversine calculations (one-time, ~30 min)</li>
      <li><strong>Storage:</strong> 42,000 &times; 3 rows = 126,000 rows (trivial)</li>
      <li><strong>Query time:</strong> O(1) index lookup per request</li>
      <li><strong>Update frequency:</strong> Only when stations are added/removed (very rare)</li>
    </ul>
  </div>

  <h3>Haversine Formula</h3>
  <pre><span class="keyword">import</span> math

<span class="keyword">def</span> <span class="func">haversine_distance_km</span>(lat1, lng1, lat2, lng2):
    <span class="string">"""
    Calculate great-circle distance between two points
    on Earth using the Haversine formula.
    """</span>
    R = <span class="number">6371</span>  <span class="comment"># Earth's radius in km</span>
    dlat = math.radians(lat2 - lat1)
    dlng = math.radians(lng2 - lng1)

    a = (math.sin(dlat / <span class="number">2</span>) ** <span class="number">2</span> +
         math.cos(math.radians(lat1)) *
         math.cos(math.radians(lat2)) *
         math.sin(dlng / <span class="number">2</span>) ** <span class="number">2</span>)

    c = <span class="number">2</span> * math.atan2(math.sqrt(a), math.sqrt(<span class="number">1</span> - a))
    <span class="keyword">return</span> R * c</pre>

  <h3>Pre-Computation Cron Job</h3>
  <pre><span class="keyword">def</span> <span class="func">precompute_zip_station_mapping</span>():
    <span class="string">"""
    Nightly cron: for every zip code, find the 3 nearest stations.
    Runs ~30 min for all 42K zip codes.
    """</span>
    stations = db.query(<span class="string">"SELECT id, lat, lng FROM weather_stations"</span>)
    zip_codes = db.query(<span class="string">"SELECT zip_code, lat, lng FROM zip_code_to_coords"</span>)

    <span class="keyword">for</span> zc <span class="keyword">in</span> zip_codes:
        distances = []
        <span class="keyword">for</span> station <span class="keyword">in</span> stations:
            d = haversine_distance_km(zc.lat, zc.lng, station.lat, station.lng)
            distances.append((station.id, d))

        <span class="comment"># Sort and take top 3 nearest</span>
        distances.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])
        top_3 = distances[:<span class="number">3</span>]

        <span class="comment"># Upsert into mapping table</span>
        <span class="keyword">for</span> rank, (station_id, dist) <span class="keyword">in</span> enumerate(top_3, <span class="number">1</span>):
            db.execute(<span class="string">"""
                INSERT INTO zip_code_station_mapping
                    (zip_code, station_id, rank, distance_km)
                VALUES (%s, %s, %s, %s)
                ON CONFLICT (zip_code, rank) DO UPDATE
                    SET station_id = EXCLUDED.station_id,
                        distance_km = EXCLUDED.distance_km
            """</span>, [zc.zip_code, station_id, rank, dist])</pre>

  <h3>City-to-Zip Mapping</h3>
  <div class="card">
    <div class="card-header" style="color:var(--blue);">How to Handle City Queries?</div>
    <p>A city maps to multiple zip codes. Options:</p>
    <ul>
      <li><strong>Pick the "centroid" zip code</strong> &mdash; pre-compute the most central zip code for each city (simplest)</li>
      <li><strong>Average across all zip codes</strong> &mdash; query multiple stations and merge (more accurate but complex)</li>
      <li><strong>Let the client pick</strong> &mdash; return a list of zip codes for the city, let the client choose</li>
    </ul>
    <p style="margin-top:10px;"><strong>Recommendation:</strong> Store a <code class="inline-code">city</code> column in the zip code table. When a city is queried, pick the first zip code alphabetically or by population center. This gives a deterministic, cacheable result.</p>
  </div>

  <div class="tip-box tip-interview">
    <div class="tip-title" style="color:var(--purple);">Why Store Top 3 Stations?</div>
    <p>Storing the nearest 3 stations per zip code provides <strong>built-in fallback</strong>. If station #1 is down or has missing data for a date range, we automatically try station #2, then #3. This makes the API resilient to individual station failures without any extra infrastructure.</p>
  </div>
</section>

<!-- ==================== SECTION 5: DATA MODEL ==================== -->
<section id="data-model">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--warning), var(--accent));">&#128451;</span> Data Model</h2>

  <p>Five core tables power the system. The schema is designed for <strong>query efficiency</strong> (zip code lookups) and <strong>data integrity</strong> (unique constraints prevent duplicates).</p>

  <h3>Entity Relationship Overview</h3>
  <div class="arch-diagram">
  zip_code_to_coords               zip_code_station_mapping           weather_stations
  +------------------+             +------------------------+         +-------------------+
  | zip_code (PK)    |----&lt;-------| zip_code (FK)          |-------&gt;| id (PK)           |
  | lat              |             | station_id (FK)        |         | name              |
  | lng              |             | rank (1,2,3)           |         | lat               |
  | city             |             | distance_km            |         | lng               |
  +------------------+             +------------------------+         | reliability_score |
                                            |                         +-------------------+
                                            |                                  |
                                            |                    +-------------+-------------+
                                            |                    |                           |
                                   weather_station_actual_data   weather_station_predicted_data
                                   +---------------------------+ +-------------------------------+
                                   | id (PK)                   | | id (PK)                       |
                                   | station_id (FK)           | | station_id (FK)               |
                                   | date_actual               | | date_sent                     |
                                   | high_temp                 | | date_predicted                |
                                   | low_temp                  | | high_temp                     |
                                   +---------------------------+ | low_temp                      |
                                   UNIQUE(station_id,            +-------------------------------+
                                          date_actual)           UNIQUE(station_id,
                                                                        date_sent,
                                                                        date_predicted)</div>

  <h3>Table: weather_stations</h3>
  <div class="schema-box">
    <span class="table-name">weather_stations</span><br>
    +-----------------------+-------------------+--------------------------------------------+<br>
    | <span class="col-name">id</span>                    | <span class="col-type">SERIAL PRIMARY KEY</span> | <span class="col-comment">-- auto-incrementing station ID</span>             |<br>
    | <span class="col-name">name</span>                  | <span class="col-type">VARCHAR(100)</span>      | <span class="col-comment">-- e.g., "STATION_042"</span>                      |<br>
    | <span class="col-name">lat</span>                   | <span class="col-type">DECIMAL(9,6)</span>      | <span class="col-comment">-- latitude, e.g., 37.774900</span>                |<br>
    | <span class="col-name">lng</span>                   | <span class="col-type">DECIMAL(9,6)</span>      | <span class="col-comment">-- longitude, e.g., -122.419400</span>             |<br>
    | <span class="col-name">reliability_score</span>     | <span class="col-type">DECIMAL(5,4)</span>      | <span class="col-comment">-- 0.0000 to 1.0000, computed from history</span>  |<br>
    | <span class="col-name">last_data_received_at</span> | <span class="col-type">TIMESTAMP</span>         | <span class="col-comment">-- track freshness of station data</span>          |<br>
    | <span class="col-name">created_at</span>            | <span class="col-type">TIMESTAMP</span>         | <span class="col-comment">-- when station was registered</span>              |<br>
    +-----------------------+-------------------+--------------------------------------------+<br>
    <span class="col-constraint">INDEX</span> ON (lat, lng)  <span class="col-comment">-- for geo queries if ever needed</span>
  </div>

  <h3>Table: weather_station_actual_data</h3>
  <div class="schema-box">
    <span class="table-name">weather_station_actual_data</span><br>
    +----------------+-------------------+--------------------------------------------+<br>
    | <span class="col-name">id</span>             | <span class="col-type">SERIAL PRIMARY KEY</span> | <span class="col-comment">-- auto-incrementing row ID</span>                  |<br>
    | <span class="col-name">station_id</span>     | <span class="col-type">INTEGER NOT NULL</span>  | <span class="col-comment">-- FK to weather_stations.id</span>                 |<br>
    | <span class="col-name">date_actual</span>    | <span class="col-type">DATE NOT NULL</span>     | <span class="col-comment">-- the day this measurement is for</span>           |<br>
    | <span class="col-name">high_temp</span>      | <span class="col-type">DECIMAL(5,2)</span>      | <span class="col-comment">-- high temperature in Fahrenheit</span>            |<br>
    | <span class="col-name">low_temp</span>       | <span class="col-type">DECIMAL(5,2)</span>      | <span class="col-comment">-- low temperature in Fahrenheit</span>             |<br>
    | <span class="col-name">ingested_at</span>    | <span class="col-type">TIMESTAMP</span>         | <span class="col-comment">-- when this row was inserted/updated</span>        |<br>
    +----------------+-------------------+--------------------------------------------+<br>
    <span class="col-constraint">UNIQUE</span> (station_id, date_actual)<br>
    <span class="col-constraint">INDEX</span>  ON (station_id, date_actual)  <span class="col-comment">-- primary query path</span>
  </div>

  <h3>Table: weather_station_predicted_data</h3>
  <div class="schema-box">
    <span class="table-name">weather_station_predicted_data</span><br>
    +------------------+-------------------+--------------------------------------------+<br>
    | <span class="col-name">id</span>               | <span class="col-type">SERIAL PRIMARY KEY</span> | <span class="col-comment">-- auto-incrementing row ID</span>                  |<br>
    | <span class="col-name">station_id</span>       | <span class="col-type">INTEGER NOT NULL</span>  | <span class="col-comment">-- FK to weather_stations.id</span>                 |<br>
    | <span class="col-name">date_sent</span>        | <span class="col-type">DATE NOT NULL</span>     | <span class="col-comment">-- the day the prediction was made</span>           |<br>
    | <span class="col-name">date_predicted</span>   | <span class="col-type">DATE NOT NULL</span>     | <span class="col-comment">-- the day being predicted</span>                   |<br>
    | <span class="col-name">high_temp</span>        | <span class="col-type">DECIMAL(5,2)</span>      | <span class="col-comment">-- predicted high in Fahrenheit</span>              |<br>
    | <span class="col-name">low_temp</span>         | <span class="col-type">DECIMAL(5,2)</span>      | <span class="col-comment">-- predicted low in Fahrenheit</span>               |<br>
    | <span class="col-name">ingested_at</span>      | <span class="col-type">TIMESTAMP</span>         | <span class="col-comment">-- when this row was inserted/updated</span>        |<br>
    +------------------+-------------------+--------------------------------------------+<br>
    <span class="col-constraint">UNIQUE</span> (station_id, date_sent, date_predicted)<br>
    <span class="col-constraint">INDEX</span>  ON (station_id, date_predicted, date_sent DESC)  <span class="col-comment">-- get latest prediction for a date</span>
  </div>

  <h3>Table: zip_code_to_coords</h3>
  <div class="schema-box">
    <span class="table-name">zip_code_to_coords</span><br>
    +------------------+-------------------+--------------------------------------------+<br>
    | <span class="col-name">zip_code</span>         | <span class="col-type">VARCHAR(10) PK</span>   | <span class="col-comment">-- e.g., "94110"</span>                              |<br>
    | <span class="col-name">lat</span>              | <span class="col-type">DECIMAL(9,6)</span>      | <span class="col-comment">-- center latitude of the zip code area</span>      |<br>
    | <span class="col-name">lng</span>              | <span class="col-type">DECIMAL(9,6)</span>      | <span class="col-comment">-- center longitude of the zip code area</span>     |<br>
    | <span class="col-name">city</span>             | <span class="col-type">VARCHAR(100)</span>      | <span class="col-comment">-- e.g., "San Francisco"</span>                     |<br>
    | <span class="col-name">state</span>            | <span class="col-type">VARCHAR(2)</span>        | <span class="col-comment">-- e.g., "CA"</span>                                |<br>
    +------------------+-------------------+--------------------------------------------+<br>
    <span class="col-constraint">UNIQUE</span> (zip_code)<br>
    <span class="col-constraint">INDEX</span>  ON (city, state)  <span class="col-comment">-- for city-based lookups</span>
  </div>

  <h3>Table: zip_code_station_mapping</h3>
  <div class="schema-box">
    <span class="table-name">zip_code_station_mapping</span><br>
    +------------------+-------------------+--------------------------------------------+<br>
    | <span class="col-name">zip_code</span>         | <span class="col-type">VARCHAR(10)</span>       | <span class="col-comment">-- FK to zip_code_to_coords.zip_code</span>         |<br>
    | <span class="col-name">station_id</span>       | <span class="col-type">INTEGER</span>           | <span class="col-comment">-- FK to weather_stations.id</span>                 |<br>
    | <span class="col-name">rank</span>             | <span class="col-type">SMALLINT</span>          | <span class="col-comment">-- 1 = nearest, 2 = 2nd nearest, 3 = 3rd</span>    |<br>
    | <span class="col-name">distance_km</span>      | <span class="col-type">DECIMAL(8,2)</span>      | <span class="col-comment">-- distance from zip centroid to station</span>     |<br>
    +------------------+-------------------+--------------------------------------------+<br>
    <span class="col-constraint">PRIMARY KEY</span> (zip_code, rank)<br>
    <span class="col-constraint">INDEX</span> ON (zip_code)  <span class="col-comment">-- fast lookup for API queries</span>
  </div>

  <div class="tip-box tip-info">
    <div class="tip-title" style="color:var(--blue);">Why Separate Actual vs. Predicted Tables?</div>
    <p>The two data types have <strong>different schemas</strong> (predicted data needs <code class="inline-code">date_sent</code> and <code class="inline-code">date_predicted</code>, actual data only needs <code class="inline-code">date_actual</code>) and <strong>different query patterns</strong> (predicted data is queried with "latest prediction" logic, actual data is a simple range scan). Separating them gives cleaner indexes, simpler queries, and independent scaling. A single merged table with nullable columns would be messier and slower.</p>
  </div>
</section>

<!-- ==================== SECTION 6: API DESIGN ==================== -->
<section id="api-design">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--secondary), var(--success));">&#128268;</span> API Design</h2>

  <h3>Primary Endpoint</h3>
  <pre><span class="keyword">GET</span> <span class="string">/api/v1/weather</span>

<span class="comment">Query Parameters:</span>
  <span class="func">location</span>    = <span class="string">"94110"</span>              <span class="comment"># zip code or city name (required)</span>
  <span class="func">start_date</span> = <span class="string">"2025-01-01"</span>         <span class="comment"># ISO 8601 date (required)</span>
  <span class="func">end_date</span>   = <span class="string">"2025-01-10"</span>         <span class="comment"># ISO 8601 date (required)</span>
  <span class="func">type</span>       = <span class="string">"predicted"</span>          <span class="comment"># "actual" | "predicted" | "both" (default: "both")</span>

<span class="comment">Headers:</span>
  <span class="func">X-API-Key</span>:       <span class="string">abc123-your-api-key</span>
  <span class="func">X-Timestamp</span>:     <span class="string">1706000000</span>
  <span class="func">X-Signature</span>:     <span class="string">HMAC-SHA256(api_secret, "GET|/api/v1/weather|params|timestamp")</span></pre>

  <h3>Response Format</h3>
  <pre><span class="comment">HTTP 200 OK</span>
<span class="comment">Content-Type: application/json</span>
<span class="comment">Cache-Control: public, max-age=3600</span>
<span class="comment">X-RateLimit-Remaining: 4523</span>
<span class="comment">X-RateLimit-Reset: 1706054400</span>

{
  <span class="string">"location"</span>: {
    <span class="string">"zip_code"</span>: <span class="string">"94110"</span>,
    <span class="string">"city"</span>: <span class="string">"San Francisco"</span>,
    <span class="string">"state"</span>: <span class="string">"CA"</span>
  },
  <span class="string">"station"</span>: {
    <span class="string">"id"</span>: <span class="number">42</span>,
    <span class="string">"name"</span>: <span class="string">"STATION_042"</span>,
    <span class="string">"distance_km"</span>: <span class="number">3.2</span>,
    <span class="string">"reliability_score"</span>: <span class="number">0.94</span>
  },
  <span class="string">"data"</span>: [
    {
      <span class="string">"date"</span>: <span class="string">"2025-01-01"</span>,
      <span class="string">"type"</span>: <span class="string">"actual"</span>,
      <span class="string">"high_temp_f"</span>: <span class="number">58</span>,
      <span class="string">"low_temp_f"</span>: <span class="number">42</span>
    },
    {
      <span class="string">"date"</span>: <span class="string">"2025-01-02"</span>,
      <span class="string">"type"</span>: <span class="string">"predicted"</span>,
      <span class="string">"predicted_on"</span>: <span class="string">"2025-01-01"</span>,
      <span class="string">"high_temp_f"</span>: <span class="number">60</span>,
      <span class="string">"low_temp_f"</span>: <span class="number">45</span>
    },
    {
      <span class="string">"date"</span>: <span class="string">"2025-01-03"</span>,
      <span class="string">"type"</span>: <span class="string">"unavailable"</span>,
      <span class="string">"reason"</span>: <span class="string">"No data from primary or fallback stations"</span>
    }
  ],
  <span class="string">"metadata"</span>: {
    <span class="string">"total_days"</span>: <span class="number">10</span>,
    <span class="string">"days_with_data"</span>: <span class="number">9</span>,
    <span class="string">"fallback_used"</span>: <span class="keyword">false</span>
  }
}</pre>

  <h3>Authentication: API Keys + HMAC Signing</h3>
  <div class="card-grid">
    <div class="card" style="border-top: 3px solid var(--success);">
      <div class="card-header" style="color:var(--success);">Step 1: API Key Registration</div>
      <ul>
        <li>Clients register and receive an <code class="inline-code">api_key</code> (public) and <code class="inline-code">api_secret</code> (private)</li>
        <li>Store hashed secrets server-side, never in logs</li>
        <li>Support key rotation: client can have 2 active keys during transition</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--blue);">
      <div class="card-header" style="color:var(--blue);">Step 2: Request Signing</div>
      <ul>
        <li>Client computes <code class="inline-code">HMAC-SHA256(secret, method|path|params|timestamp)</code></li>
        <li>Includes timestamp to prevent replay attacks (reject if &gt; 5 min drift)</li>
        <li>Server recomputes HMAC and compares &mdash; rejects if mismatch</li>
      </ul>
    </div>
  </div>

  <h3>Rate Limiting</h3>
  <table>
    <thead>
      <tr>
        <th>Tier</th>
        <th>Daily Limit</th>
        <th>Burst Limit</th>
        <th>Price</th>
        <th>Use Case</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="badge badge-green">Free</span></td>
        <td>1,000 requests/day</td>
        <td>10 req/sec</td>
        <td>$0</td>
        <td>Personal projects, testing</td>
      </tr>
      <tr>
        <td><span class="badge badge-blue">Pro</span></td>
        <td>100,000 requests/day</td>
        <td>100 req/sec</td>
        <td>$49/mo</td>
        <td>Small weather apps</td>
      </tr>
      <tr>
        <td><span class="badge badge-purple">Enterprise</span></td>
        <td>Unlimited</td>
        <td>1,000 req/sec</td>
        <td>Custom</td>
        <td>Newspapers, major apps</td>
      </tr>
    </tbody>
  </table>

  <div class="tip-box tip-warning">
    <div class="tip-title" style="color:var(--warning);">Rate Limiting Implementation</div>
    <p>Use a <strong>sliding window counter</strong> in Redis. Key: <code class="inline-code">ratelimit:{api_key}:{window}</code>. On each request, <code class="inline-code">INCR</code> the key and <code class="inline-code">EXPIRE</code> it at the window boundary. If count exceeds limit, return <code class="inline-code">429</code> with <code class="inline-code">Retry-After</code> header. The burst limit uses a separate <strong>token bucket</strong> to allow short spikes while enforcing sustained throughput limits.</p>
  </div>

  <h3>Error Responses</h3>
  <pre><span class="comment">// 400 Bad Request - Invalid parameters</span>
{ <span class="string">"error"</span>: <span class="string">"invalid_date_range"</span>, <span class="string">"message"</span>: <span class="string">"end_date must be after start_date"</span> }

<span class="comment">// 401 Unauthorized - Missing or invalid API key</span>
{ <span class="string">"error"</span>: <span class="string">"unauthorized"</span>, <span class="string">"message"</span>: <span class="string">"Invalid API key or HMAC signature"</span> }

<span class="comment">// 404 Not Found - Unknown location</span>
{ <span class="string">"error"</span>: <span class="string">"location_not_found"</span>, <span class="string">"message"</span>: <span class="string">"No zip code or city matching '99999'"</span> }

<span class="comment">// 429 Too Many Requests - Rate limited</span>
{ <span class="string">"error"</span>: <span class="string">"rate_limited"</span>, <span class="string">"retry_after_seconds"</span>: <span class="number">30</span> }

<span class="comment">// 503 Service Unavailable - Data not yet ingested</span>
{ <span class="string">"error"</span>: <span class="string">"data_unavailable"</span>, <span class="string">"message"</span>: <span class="string">"Today's data is still processing"</span> }</pre>

  <h3>API Request Flow</h3>
  <div class="arch-diagram">
  Client Request                API Gateway              App Server              Database
  +-----------+              +-----------+             +-----------+           +-----------+
  |           |  HTTPS       |           |  Validate   |           |  Query    |           |
  |  Weather  |------------>| Rate Limit |----------->| Resolve   |---------->| PostgreSQL|
  |  App      |  + API Key  | + Auth     |             | Zip->Stn  |           |           |
  |           |             | + HMAC     |             | Fetch Data|           |           |
  |           |<------------|           |<-----------| Format    |<----------|           |
  |           |  JSON resp  |           |  JSON       | Response  |  Rows     |           |
  +-----------+              +-----------+             +-----------+           +-----------+
                                  |                         |
                                  v                         v
                            +----------+             +----------+
                            | CDN Cache|             | Redis    |
                            | (Popular |             | Cache    |
                            |  zips)   |             |          |
                            +----------+             +----------+</div>
</section>

<!-- ==================== SECTION 7: CACHING ==================== -->
<section id="caching">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--success), var(--secondary));">&#9889;</span> Caching Strategy</h2>

  <p>With millions of API clients and a dataset that only changes once daily, caching is the <strong>single most impactful optimization</strong>. The trick is understanding what changes when and setting TTLs accordingly.</p>

  <h3>What to Cache</h3>
  <div class="card-grid">
    <div class="card" style="border-top: 3px solid var(--primary);">
      <div class="card-header" style="color:var(--primary);">Today's Forecast by Zip Code</div>
      <ul>
        <li><strong>Key:</strong> <code class="inline-code">forecast:{zip_code}:{date}</code></li>
        <li><strong>TTL:</strong> 1 hour (re-fetch after new data arrives)</li>
        <li><strong>Changes:</strong> Daily when new CSV arrives</li>
        <li><strong>Hit rate:</strong> Very high &mdash; popular zip codes queried thousands of times</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--secondary);">
      <div class="card-header" style="color:var(--secondary);">Zip Code to Station Mapping</div>
      <ul>
        <li><strong>Key:</strong> <code class="inline-code">zip_station:{zip_code}</code></li>
        <li><strong>TTL:</strong> 7 days (barely changes)</li>
        <li><strong>Changes:</strong> Only when stations added/removed</li>
        <li><strong>Hit rate:</strong> Nearly 100% &mdash; this is essentially static data</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--purple);">
      <div class="card-header" style="color:var(--purple);">Historical Data by Station + Date</div>
      <ul>
        <li><strong>Key:</strong> <code class="inline-code">historical:{station_id}:{date}</code></li>
        <li><strong>TTL:</strong> 24 hours (never changes once written)</li>
        <li><strong>Changes:</strong> Never (actuals are immutable once recorded)</li>
        <li><strong>Hit rate:</strong> Medium &mdash; historical queries are less common</li>
      </ul>
    </div>
  </div>

  <h3>Cache Layers</h3>
  <div class="step-grid">
    <div class="step-item" style="border-left: 3px solid var(--primary);">
      <div class="step-num">1</div>
      <div class="step-content">
        <strong>CDN Layer (CloudFront / Fastly)</strong>
        <p>Cache full API responses for the most popular zip codes at edge locations. Use <code class="inline-code">Cache-Control: public, max-age=3600</code> headers. The CDN serves ~80% of requests without hitting the origin server. Vary by <code class="inline-code">location</code> + <code class="inline-code">date range</code> + <code class="inline-code">type</code>.</p>
      </div>
    </div>
    <div class="step-item" style="border-left: 3px solid var(--secondary);">
      <div class="step-num">2</div>
      <div class="step-content">
        <strong>Application Cache (Redis)</strong>
        <p>For CDN cache misses, the app server checks Redis before hitting the database. Store pre-formatted JSON responses keyed by the query parameters. Redis serves ~95% of remaining requests. Use a Redis cluster with ~2 GB memory (the entire working set fits easily).</p>
      </div>
    </div>
    <div class="step-item" style="border-left: 3px solid var(--blue);">
      <div class="step-num">3</div>
      <div class="step-content">
        <strong>Database (PostgreSQL)</strong>
        <p>The final fallback. Only ~1-5% of requests actually hit the DB (cold cache, unusual queries, first request after invalidation). With proper indexes, even a direct DB query completes in &lt; 10ms.</p>
      </div>
    </div>
  </div>

  <h3>Cache Invalidation Strategy</h3>
  <pre><span class="keyword">def</span> <span class="func">invalidate_cache_for_station</span>(station_id):
    <span class="string">"""
    Called after successful CSV ingestion for a station.
    Invalidates all cached data that depends on this station.
    """</span>
    <span class="comment"># 1. Find all zip codes mapped to this station</span>
    zip_codes = db.query(<span class="string">"""
        SELECT zip_code FROM zip_code_station_mapping
        WHERE station_id = %s
    """</span>, [station_id])

    <span class="comment"># 2. Delete Redis cache entries for these zip codes</span>
    <span class="keyword">for</span> zc <span class="keyword">in</span> zip_codes:
        pattern = <span class="string">f"forecast:{zc.zip_code}:*"</span>
        redis.delete_pattern(pattern)

    <span class="comment"># 3. Purge CDN for these zip codes</span>
    cdn.purge_by_tag(<span class="string">f"station-{station_id}"</span>)

    <span class="comment"># 4. Log invalidation event</span>
    logger.info(<span class="string">f"Cache invalidated for station {station_id}, "
                f"affecting {len(zip_codes)} zip codes"</span>)</pre>

  <div class="tip-box tip-success">
    <div class="tip-title" style="color:var(--success);">TTL Cheat Sheet</div>
    <table style="margin-top:10px;">
      <thead>
        <tr>
          <th>Data Type</th>
          <th>CDN TTL</th>
          <th>Redis TTL</th>
          <th>Rationale</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Today's forecast</td>
          <td>1 hour</td>
          <td>1 hour</td>
          <td>Updates daily; 1hr ensures freshness within same day</td>
        </tr>
        <tr>
          <td>Historical actuals</td>
          <td>24 hours</td>
          <td>24 hours</td>
          <td>Immutable &mdash; once recorded, never changes</td>
        </tr>
        <tr>
          <td>Zip-to-station mapping</td>
          <td>N/A</td>
          <td>7 days</td>
          <td>Almost static; only changes when stations are added</td>
        </tr>
        <tr>
          <td>Station metadata</td>
          <td>N/A</td>
          <td>24 hours</td>
          <td>Reliability score updates daily</td>
        </tr>
      </tbody>
    </table>
  </div>
</section>

<!-- ==================== SECTION 8: EDGE CASES ==================== -->
<section id="edge-cases">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--danger), var(--warning));">&#9888;</span> Handling Edge Cases</h2>

  <p>Real-world weather data is messy. Stations go offline, data arrives late, readings are wrong. A Principal Engineer must design for every failure mode.</p>

  <h3>Missing Data: Station Fallback</h3>
  <div class="card" style="border-top: 3px solid var(--primary);">
    <div class="card-header" style="color:var(--primary);">Fallback Chain: Station #1 &rarr; #2 &rarr; #3 &rarr; Unavailable</div>
    <pre style="margin-top:10px;"><span class="keyword">def</span> <span class="func">get_weather_for_zip</span>(zip_code, start_date, end_date, data_type):
    <span class="string">"""Try nearest station first, fall back to 2nd and 3rd."""</span>
    stations = db.query(<span class="string">"""
        SELECT station_id, distance_km, rank
        FROM zip_code_station_mapping
        WHERE zip_code = %s
        ORDER BY rank ASC
    """</span>, [zip_code])

    <span class="keyword">for</span> station <span class="keyword">in</span> stations:
        data = fetch_station_data(
            station.station_id, start_date, end_date, data_type
        )
        <span class="keyword">if</span> data <span class="keyword">and</span> has_sufficient_coverage(data, start_date, end_date):
            <span class="keyword">return</span> {
                <span class="string">"station"</span>: station,
                <span class="string">"data"</span>: data,
                <span class="string">"fallback_used"</span>: station.rank > <span class="number">1</span>
            }

    <span class="comment"># No station has data - return partial with unavailable markers</span>
    <span class="keyword">return</span> build_unavailable_response(zip_code, start_date, end_date)

<span class="keyword">def</span> <span class="func">has_sufficient_coverage</span>(data, start_date, end_date):
    <span class="string">"""Require at least 70% of requested days to have data."""</span>
    total_days = (end_date - start_date).days + <span class="number">1</span>
    days_with_data = len([d <span class="keyword">for</span> d <span class="keyword">in</span> data <span class="keyword">if</span> d.high_temp <span class="keyword">is not None</span>])
    <span class="keyword">return</span> days_with_data / total_days >= <span class="number">0.7</span></pre>
  </div>

  <h3>Unreliable Stations: Reliability Scoring</h3>
  <div class="card" style="border-top: 3px solid var(--warning);">
    <div class="card-header" style="color:var(--warning);">Tracking Prediction Accuracy Over Time</div>
    <p>Once actual data arrives, we can compare it against past predictions to score each station's reliability.</p>
    <pre style="margin-top:10px;"><span class="keyword">def</span> <span class="func">compute_reliability_score</span>(station_id, lookback_days=<span class="number">90</span>):
    <span class="string">"""
    Compare predictions to actuals for the last N days.
    Score = 1.0 - (avg_error / max_reasonable_error)
    """</span>
    results = db.query(<span class="string">"""
        SELECT
            p.date_predicted,
            p.high_temp AS pred_high,
            p.low_temp AS pred_low,
            a.high_temp AS actual_high,
            a.low_temp AS actual_low
        FROM weather_station_predicted_data p
        JOIN weather_station_actual_data a
            ON p.station_id = a.station_id
            AND p.date_predicted = a.date_actual
        WHERE p.station_id = %s
            AND p.date_sent = p.date_predicted - INTERVAL '1 day'
            AND a.date_actual >= CURRENT_DATE - INTERVAL '%s days'
    """</span>, [station_id, lookback_days])

    <span class="keyword">if not</span> results:
        <span class="keyword">return</span> <span class="number">0.5</span>  <span class="comment"># Default for stations with no comparison data</span>

    errors = []
    <span class="keyword">for</span> r <span class="keyword">in</span> results:
        high_err = abs(r.pred_high - r.actual_high)
        low_err = abs(r.pred_low - r.actual_low)
        errors.append((high_err + low_err) / <span class="number">2</span>)

    avg_error = sum(errors) / len(errors)
    <span class="comment"># Normalize: 0 error = 1.0, 20F error = 0.0</span>
    score = max(<span class="number">0</span>, <span class="number">1.0</span> - (avg_error / <span class="number">20.0</span>))
    <span class="keyword">return</span> round(score, <span class="number">4</span>)</pre>
  </div>

  <h3>Multiple Stations in Same Area</h3>
  <div class="comparison">
    <div class="card option-a">
      <div class="card-header" style="color:var(--secondary);">Option A: Use Most Reliable</div>
      <ul>
        <li>Pick the station with the highest reliability score</li>
        <li><span class="badge badge-green">Simple</span> &mdash; one station per query</li>
        <li><span class="badge badge-green">Consistent</span> &mdash; deterministic results</li>
        <li><span style="color:var(--danger);">Con:</span> Ignores useful data from other stations</li>
      </ul>
    </div>
    <div class="card option-b">
      <div class="card-header" style="color:var(--accent);">Option B: Weighted Average</div>
      <ul>
        <li>Average temperatures from nearby stations, weighted by reliability &times; inverse distance</li>
        <li><span class="badge badge-orange">More accurate</span> &mdash; uses all available data</li>
        <li><span class="badge badge-orange">Harder to cache</span> &mdash; results depend on all stations</li>
        <li><span style="color:var(--danger);">Con:</span> More complex, harder to explain to users</li>
      </ul>
    </div>
  </div>

  <div class="tip-box tip-interview">
    <div class="tip-title" style="color:var(--purple);">Recommendation for Interview</div>
    <p><strong>Start with Option A</strong> (most reliable station) for simplicity and cacheability. Mention Option B as a future enhancement. The interviewer wants to see you make a pragmatic choice and justify it, not over-engineer the first version.</p>
  </div>

  <h3>Other Edge Cases</h3>
  <div class="card-grid">
    <div class="card">
      <div class="card-header" style="color:var(--danger);">Station Goes Permanently Offline</div>
      <ul>
        <li>If no data received for 30 days, mark station as <code class="inline-code">inactive</code></li>
        <li>Re-run zip-to-station mapping cron to exclude inactive stations</li>
        <li>Zip codes previously mapped to it automatically get new nearest station</li>
      </ul>
    </div>
    <div class="card">
      <div class="card-header" style="color:var(--warning);">Impossible Temperature Readings</div>
      <ul>
        <li>Validation: reject if high &lt; low, or outside -60F to 140F range</li>
        <li>Statistical: reject if &gt; 3 standard deviations from rolling 30-day average</li>
        <li>Alert on-call if a station starts sending suspicious data</li>
      </ul>
    </div>
    <div class="card">
      <div class="card-header" style="color:var(--blue);">Date Range Spanning Actual + Predicted</div>
      <ul>
        <li>A query for Jan 1-10 where today is Jan 5: days 1-4 are actual, 5-10 are predicted</li>
        <li>Return both types with clear <code class="inline-code">type</code> field per day</li>
        <li>If client requests <code class="inline-code">type=actual</code> for future dates, return empty with explanation</li>
      </ul>
    </div>
    <div class="card">
      <div class="card-header" style="color:var(--purple);">New Zip Code Created</div>
      <ul>
        <li>USPS creates ~50-100 new zip codes per year</li>
        <li>Quarterly update of zip code coordinates table from USPS dataset</li>
        <li>Re-run mapping cron after zip code table update</li>
      </ul>
    </div>
  </div>
</section>

<!-- ==================== SECTION 9: SCALING ==================== -->
<section id="scaling">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--blue), var(--purple));">&#128640;</span> Scaling Strategy</h2>

  <p>The beauty of this system: the data is small (~10 GB), but the read traffic is potentially massive (millions of API clients). This is a <strong>read-heavy, write-light</strong> system. Scaling strategy focuses entirely on the read path.</p>

  <h3>Architecture Overview</h3>
  <div class="arch-diagram">
<svg viewBox="0 0 1100 620" xmlns="http://www.w3.org/2000/svg" font-family="Segoe UI, system-ui, sans-serif">
  <defs>
    <!-- Shadow filter -->
    <filter id="ws-shadow" x="-4%" y="-4%" width="108%" height="112%">
      <feDropShadow dx="0" dy="3" stdDeviation="4" flood-color="#000" flood-opacity="0.45"/>
    </filter>
    <!-- Gradients -->
    <linearGradient id="ws-g1" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#FF5A5F"/><stop offset="100%" stop-color="#E04850"/></linearGradient>
    <linearGradient id="ws-g2" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#00A699"/><stop offset="100%" stop-color="#008F84"/></linearGradient>
    <linearGradient id="ws-g3" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#428BF9"/><stop offset="100%" stop-color="#2D6FD4"/></linearGradient>
    <linearGradient id="ws-g4" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#7B2FF7"/><stop offset="100%" stop-color="#5E1DD4"/></linearGradient>
    <linearGradient id="ws-g5" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#FC642D"/><stop offset="100%" stop-color="#D4511F"/></linearGradient>
    <!-- Arrowhead -->
    <marker id="ws-arrow" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="10" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8"/>
    </marker>
    <marker id="ws-arrow-dashed" viewBox="0 0 10 7" refX="10" refY="3.5" markerWidth="10" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8"/>
    </marker>
  </defs>

  <!-- ========== DATA SOURCES (Left) ========== -->
  <!-- Weather Station 1 -->
  <g filter="url(#ws-shadow)" transform="translate(30,60)">
    <rect x="0" y="0" width="130" height="80" rx="10" fill="url(#ws-g5)" opacity="0.9"/>
    <!-- Antenna icon -->
    <line x1="35" y1="30" x2="35" y2="12" stroke="#fff" stroke-width="2"/>
    <line x1="25" y1="20" x2="35" y2="12" stroke="#fff" stroke-width="1.5"/>
    <line x1="45" y1="20" x2="35" y2="12" stroke="#fff" stroke-width="1.5"/>
    <circle cx="35" cy="10" r="3" fill="#fff"/>
    <text x="65" y="36" fill="#fff" font-size="11" font-weight="700" text-anchor="middle">Weather</text>
    <text x="65" y="50" fill="rgba(255,255,255,0.9)" font-size="10" text-anchor="middle">Station 1</text>
    <text x="65" y="68" fill="rgba(255,255,255,0.7)" font-size="9" text-anchor="middle">CSV Daily</text>
  </g>
  <!-- Weather Station 2 -->
  <g filter="url(#ws-shadow)" transform="translate(30,160)">
    <rect x="0" y="0" width="130" height="80" rx="10" fill="url(#ws-g5)" opacity="0.9"/>
    <line x1="35" y1="30" x2="35" y2="12" stroke="#fff" stroke-width="2"/>
    <line x1="25" y1="20" x2="35" y2="12" stroke="#fff" stroke-width="1.5"/>
    <line x1="45" y1="20" x2="35" y2="12" stroke="#fff" stroke-width="1.5"/>
    <circle cx="35" cy="10" r="3" fill="#fff"/>
    <text x="65" y="36" fill="#fff" font-size="11" font-weight="700" text-anchor="middle">Weather</text>
    <text x="65" y="50" fill="rgba(255,255,255,0.9)" font-size="10" text-anchor="middle">Station 2</text>
    <text x="65" y="68" fill="rgba(255,255,255,0.7)" font-size="9" text-anchor="middle">CSV Daily</text>
  </g>
  <!-- Weather Station N -->
  <g filter="url(#ws-shadow)" transform="translate(30,260)">
    <rect x="0" y="0" width="130" height="80" rx="10" fill="url(#ws-g5)" opacity="0.9"/>
    <line x1="35" y1="30" x2="35" y2="12" stroke="#fff" stroke-width="2"/>
    <line x1="25" y1="20" x2="35" y2="12" stroke="#fff" stroke-width="1.5"/>
    <line x1="45" y1="20" x2="35" y2="12" stroke="#fff" stroke-width="1.5"/>
    <circle cx="35" cy="10" r="3" fill="#fff"/>
    <text x="65" y="36" fill="#fff" font-size="11" font-weight="700" text-anchor="middle">Weather</text>
    <text x="65" y="50" fill="rgba(255,255,255,0.9)" font-size="10" text-anchor="middle">Station N</text>
    <text x="65" y="68" fill="rgba(255,255,255,0.7)" font-size="9" text-anchor="middle">CSV Daily</text>
  </g>
  <text x="95" y="46" fill="#94a3b8" font-size="12" font-weight="600" text-anchor="middle">DATA SOURCES</text>

  <!-- ========== INGESTION (CSV Parser / Cron Job) ========== -->
  <g filter="url(#ws-shadow)" transform="translate(220,140)">
    <rect x="0" y="0" width="140" height="90" rx="10" fill="url(#ws-g4)" opacity="0.9"/>
    <!-- Gear icon -->
    <circle cx="30" cy="30" r="14" fill="none" stroke="#fff" stroke-width="2"/>
    <circle cx="30" cy="30" r="5" fill="#fff"/>
    <line x1="30" y1="13" x2="30" y2="19" stroke="#fff" stroke-width="2.5"/>
    <line x1="30" y1="41" x2="30" y2="47" stroke="#fff" stroke-width="2.5"/>
    <line x1="13" y1="30" x2="19" y2="30" stroke="#fff" stroke-width="2.5"/>
    <line x1="41" y1="30" x2="47" y2="30" stroke="#fff" stroke-width="2.5"/>
    <text x="85" y="32" fill="#fff" font-size="11" font-weight="700" text-anchor="middle">CSV Parser</text>
    <text x="85" y="48" fill="rgba(255,255,255,0.9)" font-size="10" text-anchor="middle">Cron Job</text>
    <text x="70" y="76" fill="rgba(255,255,255,0.7)" font-size="9" text-anchor="middle">Daily Ingestion</text>
  </g>

  <!-- Arrows: Stations -> CSV Parser -->
  <line x1="160" y1="100" x2="220" y2="175" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>
  <line x1="160" y1="200" x2="220" y2="185" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>
  <line x1="160" y1="300" x2="220" y2="200" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>

  <!-- ========== PostgreSQL (Weather Data DB) ========== -->
  <g filter="url(#ws-shadow)" transform="translate(250,290)">
    <!-- DB Cylinder -->
    <ellipse cx="55" cy="15" rx="50" ry="14" fill="#428BF9"/>
    <rect x="5" y="15" width="100" height="55" fill="#428BF9"/>
    <ellipse cx="55" cy="70" rx="50" ry="14" fill="#3070D0"/>
    <ellipse cx="55" cy="15" rx="50" ry="14" fill="#5DA0FF"/>
    <text x="55" y="40" fill="#fff" font-size="11" font-weight="700" text-anchor="middle">PostgreSQL</text>
    <text x="55" y="55" fill="rgba(255,255,255,0.9)" font-size="9" text-anchor="middle">Weather Data</text>
    <text x="55" y="68" fill="rgba(255,255,255,0.7)" font-size="8" text-anchor="middle">Primary + 2 Replicas</text>
  </g>

  <!-- Arrow: CSV Parser -> PostgreSQL -->
  <line x1="290" y1="230" x2="300" y2="290" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>

  <!-- ========== Zip-to-Station Mapper (Cron) ========== -->
  <g filter="url(#ws-shadow)" transform="translate(220,430)">
    <rect x="0" y="0" width="140" height="80" rx="10" fill="url(#ws-g2)" opacity="0.9"/>
    <!-- Gear icon -->
    <circle cx="28" cy="26" r="12" fill="none" stroke="#fff" stroke-width="1.8"/>
    <circle cx="28" cy="26" r="4" fill="#fff"/>
    <line x1="28" y1="12" x2="28" y2="17" stroke="#fff" stroke-width="2"/>
    <line x1="28" y1="35" x2="28" y2="40" stroke="#fff" stroke-width="2"/>
    <line x1="14" y1="26" x2="19" y2="26" stroke="#fff" stroke-width="2"/>
    <line x1="37" y1="26" x2="42" y2="26" stroke="#fff" stroke-width="2"/>
    <text x="90" y="28" fill="#fff" font-size="10" font-weight="700" text-anchor="middle">Zip-to-Station</text>
    <text x="90" y="44" fill="rgba(255,255,255,0.9)" font-size="10" text-anchor="middle">Mapper</text>
    <text x="70" y="68" fill="rgba(255,255,255,0.7)" font-size="9" text-anchor="middle">Cron (Weekly)</text>
  </g>

  <!-- Arrow: Mapper -> PostgreSQL (stores mapping) -->
  <line x1="300" y1="430" x2="305" y2="384" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>

  <!-- ========== External Zip Code Service (dashed cloud) ========== -->
  <g filter="url(#ws-shadow)" transform="translate(40,440)">
    <rect x="0" y="0" width="130" height="60" rx="8" fill="none" stroke="#94a3b8" stroke-width="1.5" stroke-dasharray="6 3"/>
    <!-- Cloud icon -->
    <ellipse cx="45" cy="24" rx="16" ry="10" fill="none" stroke="#94a3b8" stroke-width="1.2"/>
    <ellipse cx="60" cy="28" rx="12" ry="9" fill="none" stroke="#94a3b8" stroke-width="1.2"/>
    <ellipse cx="38" cy="30" rx="10" ry="7" fill="none" stroke="#94a3b8" stroke-width="1.2"/>
    <text x="65" y="52" fill="#94a3b8" font-size="9" text-anchor="middle">Zip Code Service</text>
  </g>

  <!-- Arrow: External Zip -> Mapper (dashed) -->
  <line x1="170" y1="470" x2="220" y2="470" stroke="#94a3b8" stroke-width="1.5" stroke-dasharray="6 3" marker-end="url(#ws-arrow-dashed)"/>

  <!-- ========== API Gateway ========== -->
  <g filter="url(#ws-shadow)" transform="translate(460,130)">
    <rect x="0" y="0" width="140" height="100" rx="10" fill="url(#ws-g1)" opacity="0.9"/>
    <!-- Shield icon -->
    <path d="M70,14 L90,24 L90,44 C90,58 70,66 70,66 C70,66 50,58 50,44 L50,24 Z" fill="none" stroke="#fff" stroke-width="2"/>
    <!-- Checkmark inside shield -->
    <polyline points="60,40 67,47 80,32" fill="none" stroke="#fff" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
    <text x="70" y="78" fill="#fff" font-size="11" font-weight="700" text-anchor="middle">API Gateway</text>
    <text x="70" y="93" fill="rgba(255,255,255,0.8)" font-size="8" text-anchor="middle">Auth + Rate Limit</text>
  </g>

  <!-- ========== Weather API Service ========== -->
  <g filter="url(#ws-shadow)" transform="translate(460,290)">
    <rect x="0" y="0" width="140" height="80" rx="10" fill="url(#ws-g3)" opacity="0.9"/>
    <text x="70" y="30" fill="#fff" font-size="12" font-weight="700" text-anchor="middle">Weather API</text>
    <text x="70" y="48" fill="rgba(255,255,255,0.9)" font-size="10" text-anchor="middle">Service</text>
    <text x="70" y="66" fill="rgba(255,255,255,0.7)" font-size="9" text-anchor="middle">Stateless</text>
  </g>

  <!-- Arrow: API Gateway -> Weather Service -->
  <line x1="530" y1="230" x2="530" y2="290" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>

  <!-- Arrow: Weather Service -> PostgreSQL -->
  <line x1="460" y1="340" x2="350" y2="340" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>
  <text x="405" y="333" fill="#94a3b8" font-size="8" text-anchor="middle">cache miss</text>

  <!-- ========== Redis Cache ========== -->
  <g filter="url(#ws-shadow)" transform="translate(460,430)">
    <!-- Diamond shape -->
    <polygon points="70,6 134,50 70,94 6,50" fill="#ef4444" opacity="0.9"/>
    <text x="70" y="42" fill="#fff" font-size="12" font-weight="700" text-anchor="middle">Redis</text>
    <text x="70" y="56" fill="rgba(255,255,255,0.9)" font-size="9" text-anchor="middle">Cache Layer</text>
    <text x="70" y="68" fill="rgba(255,255,255,0.7)" font-size="8" text-anchor="middle">Forecast + Mapping</text>
  </g>

  <!-- Arrow: Weather Service <-> Redis -->
  <line x1="530" y1="370" x2="530" y2="430" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>
  <text x="545" y="400" fill="#94a3b8" font-size="8">lookup</text>

  <!-- ========== CDN ========== -->
  <g filter="url(#ws-shadow)" transform="translate(680,60)">
    <rect x="0" y="0" width="140" height="90" rx="10" fill="rgba(245,158,11,0.15)" stroke="#f59e0b" stroke-width="1.5"/>
    <!-- Globe icon -->
    <circle cx="70" cy="34" r="18" fill="none" stroke="#f59e0b" stroke-width="1.5"/>
    <ellipse cx="70" cy="34" rx="8" ry="18" fill="none" stroke="#f59e0b" stroke-width="1"/>
    <line x1="52" y1="34" x2="88" y2="34" stroke="#f59e0b" stroke-width="1"/>
    <line x1="55" y1="24" x2="85" y2="24" stroke="#f59e0b" stroke-width="0.7"/>
    <line x1="55" y1="44" x2="85" y2="44" stroke="#f59e0b" stroke-width="0.7"/>
    <text x="70" y="66" fill="#f59e0b" font-size="11" font-weight="700" text-anchor="middle">CDN Edge</text>
    <text x="70" y="80" fill="rgba(245,158,11,0.7)" font-size="8" text-anchor="middle">~80% hit rate</text>
  </g>

  <!-- Arrow: CDN -> API Gateway -->
  <line x1="710" y1="150" x2="600" y2="170" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>
  <text x="660" y="150" fill="#94a3b8" font-size="8">cache miss</text>

  <!-- ========== CLIENTS (Right) ========== -->
  <!-- Client 1: Weather Websites -->
  <g filter="url(#ws-shadow)" transform="translate(900,60)">
    <rect x="0" y="0" width="150" height="65" rx="10" fill="rgba(66,139,249,0.1)" stroke="#428BF9" stroke-width="1"/>
    <!-- Monitor icon -->
    <rect x="15" y="10" width="28" height="20" rx="2" fill="none" stroke="#428BF9" stroke-width="1.5"/>
    <line x1="29" y1="30" x2="29" y2="38" stroke="#428BF9" stroke-width="1.5"/>
    <line x1="21" y1="38" x2="37" y2="38" stroke="#428BF9" stroke-width="1.5"/>
    <text x="95" y="24" fill="#428BF9" font-size="10" font-weight="600" text-anchor="middle">Weather</text>
    <text x="95" y="38" fill="rgba(66,139,249,0.7)" font-size="9" text-anchor="middle">Websites</text>
    <text x="75" y="56" fill="rgba(66,139,249,0.5)" font-size="8" text-anchor="middle">API Consumers</text>
  </g>
  <!-- Client 2: Newspapers -->
  <g filter="url(#ws-shadow)" transform="translate(900,145)">
    <rect x="0" y="0" width="150" height="65" rx="10" fill="rgba(66,139,249,0.1)" stroke="#428BF9" stroke-width="1"/>
    <rect x="15" y="10" width="28" height="20" rx="2" fill="none" stroke="#428BF9" stroke-width="1.5"/>
    <line x1="29" y1="30" x2="29" y2="38" stroke="#428BF9" stroke-width="1.5"/>
    <line x1="21" y1="38" x2="37" y2="38" stroke="#428BF9" stroke-width="1.5"/>
    <text x="95" y="24" fill="#428BF9" font-size="10" font-weight="600" text-anchor="middle">Newspapers</text>
    <text x="95" y="38" fill="rgba(66,139,249,0.7)" font-size="9" text-anchor="middle">Print Media</text>
    <text x="75" y="56" fill="rgba(66,139,249,0.5)" font-size="8" text-anchor="middle">API Consumers</text>
  </g>
  <!-- Client 3: Mobile Apps -->
  <g filter="url(#ws-shadow)" transform="translate(900,230)">
    <rect x="0" y="0" width="150" height="65" rx="10" fill="rgba(66,139,249,0.1)" stroke="#428BF9" stroke-width="1"/>
    <rect x="15" y="10" width="28" height="20" rx="2" fill="none" stroke="#428BF9" stroke-width="1.5"/>
    <line x1="29" y1="30" x2="29" y2="38" stroke="#428BF9" stroke-width="1.5"/>
    <line x1="21" y1="38" x2="37" y2="38" stroke="#428BF9" stroke-width="1.5"/>
    <text x="95" y="24" fill="#428BF9" font-size="10" font-weight="600" text-anchor="middle">Mobile</text>
    <text x="95" y="38" fill="rgba(66,139,249,0.7)" font-size="9" text-anchor="middle">Apps</text>
    <text x="75" y="56" fill="rgba(66,139,249,0.5)" font-size="8" text-anchor="middle">API Consumers</text>
  </g>
  <text x="975" y="46" fill="#94a3b8" font-size="12" font-weight="600" text-anchor="middle">CLIENTS</text>

  <!-- Arrows: Clients -> CDN -->
  <line x1="900" y1="92" x2="820" y2="100" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>
  <line x1="900" y1="175" x2="820" y2="120" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>
  <line x1="900" y1="260" x2="820" y2="135" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>

  <!-- ========== Flow Labels ========== -->
  <rect x="650" y="520" width="420" height="80" rx="8" fill="rgba(30,41,59,0.7)" stroke="#334155" stroke-width="1"/>
  <text x="670" y="545" fill="#94a3b8" font-size="10" font-weight="600">DATA FLOW:</text>
  <line x1="670" y1="560" x2="710" y2="560" stroke="#94a3b8" stroke-width="1.5" marker-end="url(#ws-arrow)"/>
  <text x="720" y="564" fill="#94a3b8" font-size="9">Synchronous</text>
  <line x1="810" y1="560" x2="850" y2="560" stroke="#94a3b8" stroke-width="1.5" stroke-dasharray="6 3" marker-end="url(#ws-arrow-dashed)"/>
  <text x="860" y="564" fill="#94a3b8" font-size="9">Async / External</text>
  <text x="670" y="586" fill="#94a3b8" font-size="9">Client -> CDN -> API GW -> Weather Service -> Redis (hit?) -> PostgreSQL -> Response</text>

  <!-- ========== NUMBERED STEP CIRCLES ========== -->
  <!-- Step 1: Weather Stations -> CSV files daily -->
  <circle cx="185" cy="155" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="185" y="159" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">1</text>
  <!-- Step 2: CSV Parser -> PostgreSQL -->
  <circle cx="290" cy="260" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="290" y="264" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">2</text>
  <!-- Step 3: Zip Mapper -> External Zip Code Service -->
  <circle cx="195" cy="460" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="195" y="464" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">3</text>
  <!-- Step 4: Mapper -> PostgreSQL (store zip->station mapping) -->
  <circle cx="310" cy="410" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="310" y="414" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">4</text>
  <!-- Step 5: Client -> CDN -->
  <circle cx="865" cy="105" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="865" y="109" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">5</text>
  <!-- Step 6: CDN miss -> API Gateway -->
  <circle cx="658" cy="155" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="658" y="159" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">6</text>
  <!-- Step 7: API Gateway -> Weather API Service -->
  <circle cx="548" cy="260" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="548" y="264" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">7</text>
  <!-- Step 8: Weather Service -> Redis -->
  <circle cx="548" cy="400" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="548" y="404" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">8</text>
  <!-- Step 9: Redis miss -> PostgreSQL -->
  <circle cx="405" cy="350" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="405" y="354" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">9</text>
  <!-- Step 10: Response cached in Redis + CDN -->
  <circle cx="625" cy="490" r="10" fill="#FF5A5F" stroke="#fff" stroke-width="1.5"/><text x="625" y="494" fill="#fff" font-size="10" font-weight="800" text-anchor="middle">10</text>
  <text x="625" y="510" fill="#94a3b8" font-size="8" text-anchor="middle">cache response</text>
</svg>
  </div>

  <!-- ========== REQUEST FLOW REFERENCE ========== -->
  <h3>Request Flow Reference</h3>
  <table>
    <thead>
      <tr>
        <th>Step</th>
        <th>From</th>
        <th>To</th>
        <th>Protocol / Mechanism</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>1</strong></td>
        <td>Weather Stations</td>
        <td>CSV Files</td>
        <td>File Transfer (Daily)</td>
        <td>Stations emit CSV files daily via legacy FORTRAN parser</td>
      </tr>
      <tr>
        <td><strong>2</strong></td>
        <td>CSV Parser / Cron</td>
        <td>PostgreSQL</td>
        <td>SQL INSERT (Batch)</td>
        <td>Ingest daily forecasts + actuals into weather data tables</td>
      </tr>
      <tr>
        <td><strong>3</strong></td>
        <td>Zip-to-Station Mapper</td>
        <td>External Zip Code Service</td>
        <td>HTTPS API (Weekly Cron)</td>
        <td>Fetch zip code &rarr; lat/lng mappings from external service</td>
      </tr>
      <tr>
        <td><strong>4</strong></td>
        <td>Mapper</td>
        <td>PostgreSQL</td>
        <td>SQL UPSERT</td>
        <td>Store zip &rarr; nearest station mapping using haversine distance</td>
      </tr>
      <tr>
        <td><strong>5</strong></td>
        <td>Client</td>
        <td>CDN</td>
        <td>HTTPS (Cached)</td>
        <td>Cached responses for popular zip codes (~80% hit rate)</td>
      </tr>
      <tr>
        <td><strong>6</strong></td>
        <td>CDN (miss)</td>
        <td>API Gateway</td>
        <td>HTTPS</td>
        <td>API key authentication + rate limiting on cache miss</td>
      </tr>
      <tr>
        <td><strong>7</strong></td>
        <td>API Gateway</td>
        <td>Weather API Service</td>
        <td>HTTP (Internal)</td>
        <td>Query by zip code + date range, stateless service</td>
      </tr>
      <tr>
        <td><strong>8</strong></td>
        <td>Weather Service</td>
        <td>Redis</td>
        <td>Redis GET</td>
        <td>Check cache for today&rsquo;s forecast by station + dates</td>
      </tr>
      <tr>
        <td><strong>9</strong></td>
        <td>Redis (miss)</td>
        <td>PostgreSQL</td>
        <td>SQL SELECT</td>
        <td>Query weather data by station + date range on cache miss</td>
      </tr>
      <tr>
        <td><strong>10</strong></td>
        <td>Weather Service</td>
        <td>Redis + CDN</td>
        <td>Redis SET + Cache-Control</td>
        <td>Response cached in Redis + CDN for subsequent requests</td>
      </tr>
    </tbody>
  </table>

  <!-- ========== HAPPY PATH ========== -->
  <h3>Happy Path</h3>
  <div class="flow-steps">
    <div class="flow-step">Client queries zip code</div>
    <div class="flow-arrow">&rarr;</div>
    <div class="flow-step" style="border-color:var(--warning);">CDN hit (fast)</div>
    <div class="flow-arrow">&rarr;</div>
    <div class="flow-step">or CDN miss</div>
    <div class="flow-arrow">&rarr;</div>
    <div class="flow-step" style="border-color:var(--primary);">API auth (key + rate limit)</div>
    <div class="flow-arrow">&rarr;</div>
    <div class="flow-step" style="border-color:var(--danger);">Redis cache check</div>
    <div class="flow-arrow">&rarr;</div>
    <div class="flow-step" style="border-color:var(--blue);">DB query (station + dates)</div>
    <div class="flow-arrow">&rarr;</div>
    <div class="flow-step" style="border-color:var(--secondary);">Response cached (Redis + CDN)</div>
    <div class="flow-arrow">&rarr;</div>
    <div class="flow-step">Return forecast JSON</div>
  </div>

  <!-- ========== FAILURE PATHS ========== -->
  <h3>Failure Paths</h3>
  <table>
    <thead>
      <tr>
        <th>Failure Scenario</th>
        <th>Impact</th>
        <th>Mitigation / Fallback</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Station missing data</strong></td>
        <td>No forecast available for nearest station</td>
        <td>Fallback to 2nd / 3rd nearest station via haversine ranking</td>
      </tr>
      <tr>
        <td><strong>Unreliable station</strong></td>
        <td>Low prediction accuracy skews results</td>
        <td>Stations weighted by historical prediction accuracy; low-accuracy stations deprioritized</td>
      </tr>
      <tr>
        <td><strong>CSV parse error</strong></td>
        <td>Daily ingestion fails for one or more stations</td>
        <td>Skip malformed rows + fire alert; previous day&rsquo;s data remains valid in DB</td>
      </tr>
      <tr>
        <td><strong>Redis down</strong></td>
        <td>Cache layer unavailable, increased DB load</td>
        <td>Serve directly from PostgreSQL replicas; higher latency but functional</td>
      </tr>
      <tr>
        <td><strong>API key invalid</strong></td>
        <td>Unauthorized request</td>
        <td>Return <span class="inline-code">401 Unauthorized</span>; client must re-register for a valid key</td>
      </tr>
      <tr>
        <td><strong>Rate limit exceeded</strong></td>
        <td>Client sending too many requests</td>
        <td>Return <span class="inline-code">429 Too Many Requests</span> with <span class="inline-code">Retry-After</span> header</td>
      </tr>
    </tbody>
  </table>

  <h3>Scaling by Component</h3>
  <table>
    <thead>
      <tr>
        <th>Component</th>
        <th>Strategy</th>
        <th>Why</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>App Servers</strong></td>
        <td>Horizontal scaling (auto-scale group)</td>
        <td>Stateless &mdash; add more during traffic spikes (e.g., hurricane coverage)</td>
      </tr>
      <tr>
        <td><strong>PostgreSQL</strong></td>
        <td>Primary + 2 read replicas</td>
        <td>Write volume is tiny (~50K rows/day). Reads served from replicas</td>
      </tr>
      <tr>
        <td><strong>Redis</strong></td>
        <td>3-node cluster</td>
        <td>~2 GB working set. Cluster for HA, not capacity</td>
      </tr>
      <tr>
        <td><strong>CDN</strong></td>
        <td>CloudFront / Fastly</td>
        <td>Cache full responses for popular zip codes at 200+ edge locations</td>
      </tr>
      <tr>
        <td><strong>Ingestion</strong></td>
        <td>Single cron job (parallelized)</td>
        <td>5,000 CSV files processed in parallel in ~5 minutes. No scaling needed</td>
      </tr>
    </tbody>
  </table>

  <h3>Data Volume Analysis</h3>
  <div class="metric-grid">
    <div class="metric-card">
      <div class="metric-value">~55M</div>
      <div class="metric-label">Total Rows (30yr)</div>
    </div>
    <div class="metric-card">
      <div class="metric-value">~10 GB</div>
      <div class="metric-label">Total DB Size</div>
    </div>
    <div class="metric-card">
      <div class="metric-value">~50K</div>
      <div class="metric-label">New Rows / Day</div>
    </div>
    <div class="metric-card">
      <div class="metric-value">126K</div>
      <div class="metric-label">Mapping Table Rows</div>
    </div>
  </div>

  <div class="tip-box tip-success">
    <div class="tip-title" style="color:var(--success);">Key Insight: No Sharding Required</div>
    <p>5,000 stations &times; 365 days &times; 30 years = ~55M rows for actuals. Even with predictions (10x more), the total is ~600M rows &mdash; well within a single PostgreSQL instance. The entire dataset fits in ~50 GB with indexes. <strong>Do not shard this database.</strong> A single primary with read replicas is sufficient. Over-engineering the data layer is a common mistake in this interview.</p>
  </div>

  <h3>Handling Traffic Spikes</h3>
  <div class="card">
    <div class="card-header" style="color:var(--warning);">Severe Weather Events (Hurricane, Heat Wave)</div>
    <ul>
      <li><strong>Traffic spike:</strong> 10-50x normal traffic for affected zip codes during hurricanes</li>
      <li><strong>CDN absorbs it:</strong> Popular zip codes already cached at edge; new ones cache on first request</li>
      <li><strong>Auto-scale:</strong> App servers scale out from 3 to 20 instances in 2-3 minutes</li>
      <li><strong>Redis holds:</strong> Working set barely grows; it is bounded by number of zip codes, not traffic</li>
      <li><strong>DB is fine:</strong> With CDN + Redis handling 99% of reads, DB sees almost no spike</li>
    </ul>
  </div>
</section>

<!-- ==================== SECTION 10: TRADE-OFFS ==================== -->
<section id="tradeoffs">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--warning), var(--danger));">&#9878;</span> Trade-offs &amp; Design Decisions</h2>

  <p>Every design decision involves trade-offs. Here are the key decisions and their justifications. In an interview, explicitly stating trade-offs demonstrates principal-level thinking.</p>

  <h3>Trade-off 1: SQL vs. Key-Value Store</h3>
  <div class="tradeoff-grid">
    <div class="tradeoff-card" style="border-top: 3px solid var(--secondary);">
      <div class="tradeoff-title">PostgreSQL (Chosen)</div>
      <p class="pro">+ Rich querying: date ranges, joins, aggregations</p>
      <p class="pro">+ ACID guarantees for data integrity</p>
      <p class="pro">+ Familiar, well-understood, excellent tooling</p>
      <p class="pro">+ Data fits easily in one instance</p>
      <p class="con">- Slightly higher latency than KV for point lookups</p>
      <p class="verdict">Verdict: SQL wins here. The data is inherently relational and the volume is small.</p>
    </div>
    <div class="tradeoff-card" style="border-top: 3px solid var(--accent);">
      <div class="tradeoff-title">DynamoDB / Cassandra</div>
      <p class="pro">+ Sub-millisecond point lookups</p>
      <p class="pro">+ Automatic scaling (DynamoDB)</p>
      <p class="con">- Poor support for range queries across dates</p>
      <p class="con">- No joins &mdash; denormalization increases data volume</p>
      <p class="con">- Overkill for this data volume</p>
      <p class="verdict">Verdict: Over-engineered. The volume does not justify the complexity.</p>
    </div>
  </div>

  <h3>Trade-off 2: Pre-Compute vs. On-Demand Station Mapping</h3>
  <div class="tradeoff-grid">
    <div class="tradeoff-card" style="border-top: 3px solid var(--secondary);">
      <div class="tradeoff-title">Pre-Computed Mapping (Chosen)</div>
      <p class="pro">+ O(1) lookup at query time</p>
      <p class="pro">+ Perfectly cacheable</p>
      <p class="pro">+ Trivial storage (126K rows)</p>
      <p class="con">- Stale for ~24 hours when a new station is added</p>
      <p class="con">- Requires a cron job to maintain</p>
      <p class="verdict">Verdict: Staleness is acceptable since stations change very rarely.</p>
    </div>
    <div class="tradeoff-card" style="border-top: 3px solid var(--accent);">
      <div class="tradeoff-title">On-Demand Calculation</div>
      <p class="pro">+ Always fresh &mdash; instantly reflects new stations</p>
      <p class="pro">+ No cron job dependency</p>
      <p class="con">- O(N) per request (5K haversine calculations)</p>
      <p class="con">- Cannot cache the mapping independently</p>
      <p class="con">- Wastes compute on data that barely changes</p>
      <p class="verdict">Verdict: Wasteful. The freshness benefit does not justify the per-request cost.</p>
    </div>
  </div>

  <h3>Trade-off 3: Single Nearest vs. Multiple Station Aggregation</h3>
  <div class="tradeoff-grid">
    <div class="tradeoff-card" style="border-top: 3px solid var(--secondary);">
      <div class="tradeoff-title">Single Nearest Station (Chosen for V1)</div>
      <p class="pro">+ Simple &mdash; easy to understand and debug</p>
      <p class="pro">+ Highly cacheable &mdash; deterministic result per zip code</p>
      <p class="pro">+ Response clearly attributes data to one station</p>
      <p class="con">- Less accurate when nearest station is far away</p>
      <p class="verdict">Verdict: Best for V1. Simple, fast, cacheable.</p>
    </div>
    <div class="tradeoff-card" style="border-top: 3px solid var(--accent);">
      <div class="tradeoff-title">Weighted Multi-Station Average</div>
      <p class="pro">+ More accurate &mdash; interpolates between nearby readings</p>
      <p class="pro">+ Resilient to outlier stations</p>
      <p class="con">- Cache key must include all station IDs (complex invalidation)</p>
      <p class="con">- Harder to explain to users ("where does this number come from?")</p>
      <p class="verdict">Verdict: Good for V2 as an opt-in feature.</p>
    </div>
  </div>

  <h3>Trade-off 4: Aggressive Caching vs. Serve Fresh</h3>
  <div class="tradeoff-grid">
    <div class="tradeoff-card" style="border-top: 3px solid var(--secondary);">
      <div class="tradeoff-title">Aggressive Caching (Chosen)</div>
      <p class="pro">+ p50 latency &lt; 50ms (served from CDN/Redis)</p>
      <p class="pro">+ DB stays cool even during traffic spikes</p>
      <p class="pro">+ Massive cost savings (fewer app servers needed)</p>
      <p class="con">- Data can be up to 1 hour stale for forecasts</p>
      <p class="con">- Cache invalidation complexity</p>
      <p class="verdict">Verdict: Weather data changes daily. 1-hour staleness is perfectly fine.</p>
    </div>
    <div class="tradeoff-card" style="border-top: 3px solid var(--accent);">
      <div class="tradeoff-title">Always Fresh (No Caching)</div>
      <p class="pro">+ Data always up-to-date</p>
      <p class="pro">+ No cache invalidation logic</p>
      <p class="con">- Every request hits DB &mdash; high latency, high cost</p>
      <p class="con">- Cannot survive traffic spikes without massive over-provisioning</p>
      <p class="verdict">Verdict: Impractical for a public API at scale. Costs 10-100x more.</p>
    </div>
  </div>
</section>

<!-- ==================== SECTION 11: EXTENSIONS ==================== -->
<section id="extensions">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--purple), var(--primary));">&#128161;</span> Extensions &amp; Future Work</h2>

  <p>Once the core system is stable, these extensions demonstrate depth of thinking and product intuition.</p>

  <div class="card-grid">
    <div class="card" style="border-top: 3px solid var(--primary);">
      <div class="card-header" style="color:var(--primary);">Dogfooding: Internal Weather Website</div>
      <ul>
        <li>Build a weather website that consumes our own API</li>
        <li>Acts as a <strong>canary</strong> &mdash; we discover API issues before external clients do</li>
        <li>Drives real traffic patterns that inform caching strategy</li>
        <li>Showcases API capabilities to potential customers</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--secondary);">
      <div class="card-header" style="color:var(--secondary);">Prediction Accuracy Leaderboard</div>
      <ul>
        <li>Rank stations by prediction accuracy over different time horizons</li>
        <li>"Station X predicted tomorrow's temp within 1F 85% of the time"</li>
        <li>Compare 1-day vs. 5-day vs. 10-day forecast accuracy</li>
        <li>Interesting data product: "Most accurate stations in the US"</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--blue);">
      <div class="card-header" style="color:var(--blue);">Fun Analytics &amp; Insights</div>
      <ul>
        <li><strong>Most unpredictable cities</strong> &mdash; where forecasts deviate most from actuals</li>
        <li><strong>Hottest/coldest summers</strong> &mdash; historical trend analysis</li>
        <li><strong>Temperature anomalies</strong> &mdash; days that broke records</li>
        <li><strong>Climate trends</strong> &mdash; 30-year temperature trend lines per city</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--purple);">
      <div class="card-header" style="color:var(--purple);">User Accounts &amp; Preferences</div>
      <ul>
        <li>Save favorite locations for quick access</li>
        <li>Custom alerts: "Notify me if SF drops below 40F"</li>
        <li>Preferred units: Fahrenheit vs. Celsius</li>
        <li>API usage dashboard with analytics</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--warning);">
      <div class="card-header" style="color:var(--warning);">Webhooks &amp; Push Notifications</div>
      <ul>
        <li>Subscribe to weather events: severe weather, temperature thresholds</li>
        <li>Push forecast updates to registered webhook URLs</li>
        <li>Eliminates polling for clients that need real-time updates</li>
        <li>Useful for automated systems (agriculture, shipping, aviation)</li>
      </ul>
    </div>
    <div class="card" style="border-top: 3px solid var(--accent);">
      <div class="card-header" style="color:var(--accent);">International Expansion</div>
      <ul>
        <li>Partner with weather services in other countries</li>
        <li>Normalize data formats (different CSV schemas per country)</li>
        <li>Support postal codes worldwide (not just US zip codes)</li>
        <li>Multi-region deployment for global low latency</li>
      </ul>
    </div>
  </div>
</section>

<!-- ==================== SECTION 12: INTERVIEW TIPS ==================== -->
<section id="interview-tips">
  <h2><span class="icon" style="background:linear-gradient(135deg, var(--primary), var(--purple));">&#127919;</span> Interview Tips</h2>

  <div class="tip-box tip-interview">
    <div class="tip-title" style="color:var(--purple);">Tip 1: Start with the Data Flow, Not the API</div>
    <p>Most candidates jump straight to API design. Instead, start by understanding the <strong>data source</strong>: "The raw input is CSV files from weather stations. Let me first design how we ingest and store this data, then build the API on top." This shows you think about the full system, not just the interface.</p>
  </div>

  <div class="tip-box tip-success">
    <div class="tip-title" style="color:var(--success);">Tip 2: Call Out the Zip Code Problem Immediately</div>
    <p>The core insight of this problem is the <strong>impedance mismatch</strong>: users think in zip codes, data is organized by station lat/lng. State this explicitly: "The central challenge is bridging user queries (zip code) to data organization (station coordinates). This requires a geo-mapping layer." This shows you identified the hard part.</p>
  </div>

  <div class="tip-box tip-warning">
    <div class="tip-title" style="color:var(--warning);">Tip 3: Do Not Over-Engineer the Database</div>
    <p>A common mistake is proposing DynamoDB, Cassandra, or sharding for a dataset that's ~55M rows and ~10 GB. <strong>Do the math on the whiteboard:</strong> 5K stations &times; 365 &times; 30 = 55M rows. That is tiny. PostgreSQL handles this trivially. Over-engineering here signals that you did not analyze the scale before choosing technology.</p>
  </div>

  <div class="tip-box tip-interview">
    <div class="tip-title" style="color:var(--purple);">Tip 4: Explain Why You Pre-Compute</div>
    <p>When you propose pre-computing zip-to-station mappings, explain the reasoning: "Stations almost never change. Computing nearest station on every request wastes CPU on a result that's the same for months. Pre-computing trades 30 minutes of nightly batch processing for O(1) per-request lookups." This cost/benefit analysis is what distinguishes PE-level thinking.</p>
  </div>

  <div class="tip-box tip-success">
    <div class="tip-title" style="color:var(--success);">Tip 5: Talk About Failure Modes Proactively</div>
    <p>Do not wait for the interviewer to ask "what if a station goes down?" Proactively say: "I store the nearest 3 stations per zip code specifically to handle station failures. If station #1 has no data, we automatically fall back to #2 and #3." This shows you design for resilience from the start.</p>
  </div>

  <div class="tip-box tip-danger">
    <div class="tip-title" style="color:var(--danger);">Tip 6: Avoid These Common Mistakes</div>
    <ul style="margin-top:8px;">
      <li><strong>Proposing NoSQL for relational data</strong> &mdash; This is clearly relational (stations, readings, zip codes). SQL is the right choice.</li>
      <li><strong>Ignoring cache invalidation</strong> &mdash; Saying "just cache everything" without explaining when and how to invalidate is a red flag.</li>
      <li><strong>Forgetting about predicted vs. actual</strong> &mdash; The dual nature of the data (forecasts and historical) is a key design consideration.</li>
      <li><strong>Not doing back-of-envelope math</strong> &mdash; Always estimate data volume. It changes your architecture decisions fundamentally.</li>
      <li><strong>Skipping authentication and rate limiting</strong> &mdash; For a public API, these are first-class concerns, not afterthoughts.</li>
    </ul>
  </div>

  <div class="tip-box tip-info">
    <div class="tip-title" style="color:var(--blue);">Tip 7: Time Management (45-min Interview)</div>
    <table style="margin-top:10px;">
      <thead>
        <tr>
          <th>Phase</th>
          <th>Time</th>
          <th>What to Cover</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Clarify requirements</td>
          <td>3-5 min</td>
          <td>Ask about scale, clients, data format, SLAs</td>
        </tr>
        <tr>
          <td>Data ingestion</td>
          <td>5-7 min</td>
          <td>CSV parsing, validation, storage schema</td>
        </tr>
        <tr>
          <td>Geo mapping</td>
          <td>7-10 min</td>
          <td>Zip-to-station problem, haversine, pre-compute vs. on-demand</td>
        </tr>
        <tr>
          <td>API design</td>
          <td>5-7 min</td>
          <td>Endpoints, auth, rate limiting, response format</td>
        </tr>
        <tr>
          <td>Caching &amp; scaling</td>
          <td>7-10 min</td>
          <td>Cache layers, TTLs, invalidation, read replicas</td>
        </tr>
        <tr>
          <td>Edge cases &amp; trade-offs</td>
          <td>5-7 min</td>
          <td>Missing data, reliability, multi-station</td>
        </tr>
        <tr>
          <td>Extensions</td>
          <td>2-3 min</td>
          <td>Dogfooding, analytics, webhooks</td>
        </tr>
      </tbody>
    </table>
  </div>

  <h3>Key Phrases to Use in Interview</h3>
  <div class="card-grid">
    <div class="card">
      <div class="card-header" style="color:var(--primary);">When Discussing Scale</div>
      <ul>
        <li>"Let me do the math: 5K stations times 365 times 30 years is about 55 million rows. That is well within a single Postgres instance."</li>
        <li>"The scale challenge here is read-heavy, not write-heavy. Caching is our primary scaling lever."</li>
      </ul>
    </div>
    <div class="card">
      <div class="card-header" style="color:var(--secondary);">When Discussing Trade-offs</div>
      <ul>
        <li>"I chose pre-computation because the mapping changes on the order of months, but we query it on the order of milliseconds."</li>
        <li>"For V1, I would use the single nearest station for simplicity. Weighted averaging is a V2 feature once we validate demand."</li>
      </ul>
    </div>
    <div class="card">
      <div class="card-header" style="color:var(--purple);">When Discussing Reliability</div>
      <ul>
        <li>"I store top 3 nearest stations per zip code as a built-in fallback mechanism."</li>
        <li>"We track prediction accuracy over time to compute a reliability score per station, which influences station selection."</li>
      </ul>
    </div>
  </div>
</section>

</div><!-- /container -->

<!-- ==================== FOOTER ==================== -->
<footer>
  <p>National Weather Service API &mdash; System Design Deep Dive | Topic 13 of 18</p>
  <p style="margin-top:8px;">
    <a href="index.html">&#8592; All Topics</a>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <a href="../index.html">Main System Design</a>
  </p>
  <p style="margin-top:12px; font-size:0.8em;">Airbnb System Design Interview Collection &mdash; Principal Engineer Level</p>
</footer>

<script>
(function(){
  document.querySelectorAll(".diagram-box").forEach(function(box){
    var svg=box.querySelector("svg");
    if(!svg) return;
    var zoom=1, minZ=0.5, maxZ=3;
    var ctrl=document.createElement("div");
    ctrl.className="diagram-zoom-controls";
    ctrl.innerHTML='<button class="zoom-out" title="Zoom Out"></button><span class="zoom-level">100%</span><button class="zoom-in" title="Zoom In">+</button><button class="zoom-reset" title="Reset"></button><button class="zoom-fs" title="Fullscreen"></button>';
    box.insertBefore(ctrl,box.firstChild);
    var lvl=ctrl.querySelector(".zoom-level");
    function apply(){svg.style.transform="scale("+zoom+")";lvl.textContent=Math.round(zoom*100)+"%";}
    ctrl.querySelector(".zoom-in").onclick=function(){zoom=Math.min(maxZ,zoom+0.25);apply();};
    ctrl.querySelector(".zoom-out").onclick=function(){zoom=Math.max(minZ,zoom-0.25);apply();};
    ctrl.querySelector(".zoom-reset").onclick=function(){zoom=1;apply();};
    ctrl.querySelector(".zoom-fs").onclick=function(){
      box.classList.toggle("fullscreen");
      if(box.classList.contains("fullscreen")){this.textContent="";zoom=1.2;}else{this.textContent="";zoom=1;}
      apply();
    };
    box.addEventListener("wheel",function(e){
      if(e.ctrlKey){e.preventDefault();zoom=e.deltaY<0?Math.min(maxZ,zoom+0.1):Math.max(minZ,zoom-0.1);apply();}
    },{passive:false});
  });
})();
</script>
</body>
</html>